
AVR_ATMEGA32_DRIVERS.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000f38  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000032  00800060  00000f38  00000fcc  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000002  00800092  00800092  00000ffe  2**0
                  ALLOC
  3 .stab         00003390  00000000  00000000  00001000  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      0000216c  00000000  00000000  00004390  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
   4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
   8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
   c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  1c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
  54:	11 24       	eor	r1, r1
  56:	1f be       	out	0x3f, r1	; 63
  58:	cf e5       	ldi	r28, 0x5F	; 95
  5a:	d8 e0       	ldi	r29, 0x08	; 8
  5c:	de bf       	out	0x3e, r29	; 62
  5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
  60:	10 e0       	ldi	r17, 0x00	; 0
  62:	a0 e6       	ldi	r26, 0x60	; 96
  64:	b0 e0       	ldi	r27, 0x00	; 0
  66:	e8 e3       	ldi	r30, 0x38	; 56
  68:	ff e0       	ldi	r31, 0x0F	; 15
  6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
  6c:	05 90       	lpm	r0, Z+
  6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
  70:	a2 39       	cpi	r26, 0x92	; 146
  72:	b1 07       	cpc	r27, r17
  74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
  76:	10 e0       	ldi	r17, 0x00	; 0
  78:	a2 e9       	ldi	r26, 0x92	; 146
  7a:	b0 e0       	ldi	r27, 0x00	; 0
  7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
  7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
  80:	a4 39       	cpi	r26, 0x94	; 148
  82:	b1 07       	cpc	r27, r17
  84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
  86:	0e 94 70 07 	call	0xee0	; 0xee0 <main>
  8a:	0c 94 9a 07 	jmp	0xf34	; 0xf34 <_exit>

0000008e <__bad_interrupt>:
  8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <GPIO_PIN_DIRECTION_INITIALIZE>:
  92:	df 93       	push	r29
  94:	cf 93       	push	r28
  96:	00 d0       	rcall	.+0      	; 0x98 <GPIO_PIN_DIRECTION_INITIALIZE+0x6>
  98:	00 d0       	rcall	.+0      	; 0x9a <GPIO_PIN_DIRECTION_INITIALIZE+0x8>
  9a:	0f 92       	push	r0
  9c:	cd b7       	in	r28, 0x3d	; 61
  9e:	de b7       	in	r29, 0x3e	; 62
  a0:	9b 83       	std	Y+3, r25	; 0x03
  a2:	8a 83       	std	Y+2, r24	; 0x02
  a4:	81 e0       	ldi	r24, 0x01	; 1
  a6:	89 83       	std	Y+1, r24	; 0x01
  a8:	8a 81       	ldd	r24, Y+2	; 0x02
  aa:	9b 81       	ldd	r25, Y+3	; 0x03
  ac:	00 97       	sbiw	r24, 0x00	; 0
  ae:	61 f0       	breq	.+24     	; 0xc8 <GPIO_PIN_DIRECTION_INITIALIZE+0x36>
  b0:	ea 81       	ldd	r30, Y+2	; 0x02
  b2:	fb 81       	ldd	r31, Y+3	; 0x03
  b4:	80 81       	ld	r24, Z
  b6:	86 95       	lsr	r24
  b8:	86 95       	lsr	r24
  ba:	86 95       	lsr	r24
  bc:	87 70       	andi	r24, 0x07	; 7
  be:	88 2f       	mov	r24, r24
  c0:	90 e0       	ldi	r25, 0x00	; 0
  c2:	88 30       	cpi	r24, 0x08	; 8
  c4:	91 05       	cpc	r25, r1
  c6:	14 f0       	brlt	.+4      	; 0xcc <GPIO_PIN_DIRECTION_INITIALIZE+0x3a>
  c8:	19 82       	std	Y+1, r1	; 0x01
  ca:	7a c0       	rjmp	.+244    	; 0x1c0 <GPIO_PIN_DIRECTION_INITIALIZE+0x12e>
  cc:	ea 81       	ldd	r30, Y+2	; 0x02
  ce:	fb 81       	ldd	r31, Y+3	; 0x03
  d0:	80 81       	ld	r24, Z
  d2:	82 95       	swap	r24
  d4:	86 95       	lsr	r24
  d6:	86 95       	lsr	r24
  d8:	83 70       	andi	r24, 0x03	; 3
  da:	81 70       	andi	r24, 0x01	; 1
  dc:	28 2f       	mov	r18, r24
  de:	30 e0       	ldi	r19, 0x00	; 0
  e0:	3d 83       	std	Y+5, r19	; 0x05
  e2:	2c 83       	std	Y+4, r18	; 0x04
  e4:	8c 81       	ldd	r24, Y+4	; 0x04
  e6:	9d 81       	ldd	r25, Y+5	; 0x05
  e8:	00 97       	sbiw	r24, 0x00	; 0
  ea:	31 f0       	breq	.+12     	; 0xf8 <GPIO_PIN_DIRECTION_INITIALIZE+0x66>
  ec:	2c 81       	ldd	r18, Y+4	; 0x04
  ee:	3d 81       	ldd	r19, Y+5	; 0x05
  f0:	21 30       	cpi	r18, 0x01	; 1
  f2:	31 05       	cpc	r19, r1
  f4:	99 f1       	breq	.+102    	; 0x15c <GPIO_PIN_DIRECTION_INITIALIZE+0xca>
  f6:	63 c0       	rjmp	.+198    	; 0x1be <GPIO_PIN_DIRECTION_INITIALIZE+0x12c>
  f8:	ea 81       	ldd	r30, Y+2	; 0x02
  fa:	fb 81       	ldd	r31, Y+3	; 0x03
  fc:	80 81       	ld	r24, Z
  fe:	87 70       	andi	r24, 0x07	; 7
 100:	88 2f       	mov	r24, r24
 102:	90 e0       	ldi	r25, 0x00	; 0
 104:	88 0f       	add	r24, r24
 106:	99 1f       	adc	r25, r25
 108:	fc 01       	movw	r30, r24
 10a:	e0 5a       	subi	r30, 0xA0	; 160
 10c:	ff 4f       	sbci	r31, 0xFF	; 255
 10e:	a0 81       	ld	r26, Z
 110:	b1 81       	ldd	r27, Z+1	; 0x01
 112:	ea 81       	ldd	r30, Y+2	; 0x02
 114:	fb 81       	ldd	r31, Y+3	; 0x03
 116:	80 81       	ld	r24, Z
 118:	87 70       	andi	r24, 0x07	; 7
 11a:	88 2f       	mov	r24, r24
 11c:	90 e0       	ldi	r25, 0x00	; 0
 11e:	88 0f       	add	r24, r24
 120:	99 1f       	adc	r25, r25
 122:	fc 01       	movw	r30, r24
 124:	e0 5a       	subi	r30, 0xA0	; 160
 126:	ff 4f       	sbci	r31, 0xFF	; 255
 128:	01 90       	ld	r0, Z+
 12a:	f0 81       	ld	r31, Z
 12c:	e0 2d       	mov	r30, r0
 12e:	80 81       	ld	r24, Z
 130:	48 2f       	mov	r20, r24
 132:	ea 81       	ldd	r30, Y+2	; 0x02
 134:	fb 81       	ldd	r31, Y+3	; 0x03
 136:	80 81       	ld	r24, Z
 138:	86 95       	lsr	r24
 13a:	86 95       	lsr	r24
 13c:	86 95       	lsr	r24
 13e:	87 70       	andi	r24, 0x07	; 7
 140:	28 2f       	mov	r18, r24
 142:	30 e0       	ldi	r19, 0x00	; 0
 144:	81 e0       	ldi	r24, 0x01	; 1
 146:	90 e0       	ldi	r25, 0x00	; 0
 148:	02 2e       	mov	r0, r18
 14a:	02 c0       	rjmp	.+4      	; 0x150 <GPIO_PIN_DIRECTION_INITIALIZE+0xbe>
 14c:	88 0f       	add	r24, r24
 14e:	99 1f       	adc	r25, r25
 150:	0a 94       	dec	r0
 152:	e2 f7       	brpl	.-8      	; 0x14c <GPIO_PIN_DIRECTION_INITIALIZE+0xba>
 154:	80 95       	com	r24
 156:	84 23       	and	r24, r20
 158:	8c 93       	st	X, r24
 15a:	32 c0       	rjmp	.+100    	; 0x1c0 <GPIO_PIN_DIRECTION_INITIALIZE+0x12e>
 15c:	ea 81       	ldd	r30, Y+2	; 0x02
 15e:	fb 81       	ldd	r31, Y+3	; 0x03
 160:	80 81       	ld	r24, Z
 162:	87 70       	andi	r24, 0x07	; 7
 164:	88 2f       	mov	r24, r24
 166:	90 e0       	ldi	r25, 0x00	; 0
 168:	88 0f       	add	r24, r24
 16a:	99 1f       	adc	r25, r25
 16c:	fc 01       	movw	r30, r24
 16e:	e0 5a       	subi	r30, 0xA0	; 160
 170:	ff 4f       	sbci	r31, 0xFF	; 255
 172:	a0 81       	ld	r26, Z
 174:	b1 81       	ldd	r27, Z+1	; 0x01
 176:	ea 81       	ldd	r30, Y+2	; 0x02
 178:	fb 81       	ldd	r31, Y+3	; 0x03
 17a:	80 81       	ld	r24, Z
 17c:	87 70       	andi	r24, 0x07	; 7
 17e:	88 2f       	mov	r24, r24
 180:	90 e0       	ldi	r25, 0x00	; 0
 182:	88 0f       	add	r24, r24
 184:	99 1f       	adc	r25, r25
 186:	fc 01       	movw	r30, r24
 188:	e0 5a       	subi	r30, 0xA0	; 160
 18a:	ff 4f       	sbci	r31, 0xFF	; 255
 18c:	01 90       	ld	r0, Z+
 18e:	f0 81       	ld	r31, Z
 190:	e0 2d       	mov	r30, r0
 192:	80 81       	ld	r24, Z
 194:	48 2f       	mov	r20, r24
 196:	ea 81       	ldd	r30, Y+2	; 0x02
 198:	fb 81       	ldd	r31, Y+3	; 0x03
 19a:	80 81       	ld	r24, Z
 19c:	86 95       	lsr	r24
 19e:	86 95       	lsr	r24
 1a0:	86 95       	lsr	r24
 1a2:	87 70       	andi	r24, 0x07	; 7
 1a4:	28 2f       	mov	r18, r24
 1a6:	30 e0       	ldi	r19, 0x00	; 0
 1a8:	81 e0       	ldi	r24, 0x01	; 1
 1aa:	90 e0       	ldi	r25, 0x00	; 0
 1ac:	02 2e       	mov	r0, r18
 1ae:	02 c0       	rjmp	.+4      	; 0x1b4 <GPIO_PIN_DIRECTION_INITIALIZE+0x122>
 1b0:	88 0f       	add	r24, r24
 1b2:	99 1f       	adc	r25, r25
 1b4:	0a 94       	dec	r0
 1b6:	e2 f7       	brpl	.-8      	; 0x1b0 <GPIO_PIN_DIRECTION_INITIALIZE+0x11e>
 1b8:	84 2b       	or	r24, r20
 1ba:	8c 93       	st	X, r24
 1bc:	01 c0       	rjmp	.+2      	; 0x1c0 <GPIO_PIN_DIRECTION_INITIALIZE+0x12e>
 1be:	19 82       	std	Y+1, r1	; 0x01
 1c0:	89 81       	ldd	r24, Y+1	; 0x01
 1c2:	0f 90       	pop	r0
 1c4:	0f 90       	pop	r0
 1c6:	0f 90       	pop	r0
 1c8:	0f 90       	pop	r0
 1ca:	0f 90       	pop	r0
 1cc:	cf 91       	pop	r28
 1ce:	df 91       	pop	r29
 1d0:	08 95       	ret

000001d2 <GPIO_PIN_GET_DIRECTION>:
	}
	return Retval;
}
#endif
#if GPIO_PIN_CFG == GPIO_CFG_ENABLE
Std_ReturnType GPIO_PIN_GET_DIRECTION (const PIN_CFG_T *Pin,DIRECTION_T *DIR){
 1d2:	df 93       	push	r29
 1d4:	cf 93       	push	r28
 1d6:	00 d0       	rcall	.+0      	; 0x1d8 <GPIO_PIN_GET_DIRECTION+0x6>
 1d8:	00 d0       	rcall	.+0      	; 0x1da <GPIO_PIN_GET_DIRECTION+0x8>
 1da:	0f 92       	push	r0
 1dc:	cd b7       	in	r28, 0x3d	; 61
 1de:	de b7       	in	r29, 0x3e	; 62
 1e0:	9b 83       	std	Y+3, r25	; 0x03
 1e2:	8a 83       	std	Y+2, r24	; 0x02
 1e4:	7d 83       	std	Y+5, r23	; 0x05
 1e6:	6c 83       	std	Y+4, r22	; 0x04
	Std_ReturnType Retval = E_OK;
 1e8:	81 e0       	ldi	r24, 0x01	; 1
 1ea:	89 83       	std	Y+1, r24	; 0x01
	if(NULL == Pin || (Pin->PIN) >= (PORT_PIN_MAX) || NULL == DIR){
 1ec:	8a 81       	ldd	r24, Y+2	; 0x02
 1ee:	9b 81       	ldd	r25, Y+3	; 0x03
 1f0:	00 97       	sbiw	r24, 0x00	; 0
 1f2:	81 f0       	breq	.+32     	; 0x214 <GPIO_PIN_GET_DIRECTION+0x42>
 1f4:	ea 81       	ldd	r30, Y+2	; 0x02
 1f6:	fb 81       	ldd	r31, Y+3	; 0x03
 1f8:	80 81       	ld	r24, Z
 1fa:	86 95       	lsr	r24
 1fc:	86 95       	lsr	r24
 1fe:	86 95       	lsr	r24
 200:	87 70       	andi	r24, 0x07	; 7
 202:	88 2f       	mov	r24, r24
 204:	90 e0       	ldi	r25, 0x00	; 0
 206:	88 30       	cpi	r24, 0x08	; 8
 208:	91 05       	cpc	r25, r1
 20a:	24 f4       	brge	.+8      	; 0x214 <GPIO_PIN_GET_DIRECTION+0x42>
 20c:	8c 81       	ldd	r24, Y+4	; 0x04
 20e:	9d 81       	ldd	r25, Y+5	; 0x05
 210:	00 97       	sbiw	r24, 0x00	; 0
 212:	11 f4       	brne	.+4      	; 0x218 <GPIO_PIN_GET_DIRECTION+0x46>
		Retval = E_NOT_OK;
 214:	19 82       	std	Y+1, r1	; 0x01
 216:	25 c0       	rjmp	.+74     	; 0x262 <GPIO_PIN_GET_DIRECTION+0x90>
	}
	else{
		*DIR = READ_BIT(*(DDR_REG[Pin->PORT]),Pin->PIN);
 218:	ea 81       	ldd	r30, Y+2	; 0x02
 21a:	fb 81       	ldd	r31, Y+3	; 0x03
 21c:	80 81       	ld	r24, Z
 21e:	87 70       	andi	r24, 0x07	; 7
 220:	88 2f       	mov	r24, r24
 222:	90 e0       	ldi	r25, 0x00	; 0
 224:	88 0f       	add	r24, r24
 226:	99 1f       	adc	r25, r25
 228:	fc 01       	movw	r30, r24
 22a:	e0 5a       	subi	r30, 0xA0	; 160
 22c:	ff 4f       	sbci	r31, 0xFF	; 255
 22e:	01 90       	ld	r0, Z+
 230:	f0 81       	ld	r31, Z
 232:	e0 2d       	mov	r30, r0
 234:	80 81       	ld	r24, Z
 236:	28 2f       	mov	r18, r24
 238:	30 e0       	ldi	r19, 0x00	; 0
 23a:	ea 81       	ldd	r30, Y+2	; 0x02
 23c:	fb 81       	ldd	r31, Y+3	; 0x03
 23e:	80 81       	ld	r24, Z
 240:	86 95       	lsr	r24
 242:	86 95       	lsr	r24
 244:	86 95       	lsr	r24
 246:	87 70       	andi	r24, 0x07	; 7
 248:	88 2f       	mov	r24, r24
 24a:	90 e0       	ldi	r25, 0x00	; 0
 24c:	a9 01       	movw	r20, r18
 24e:	02 c0       	rjmp	.+4      	; 0x254 <GPIO_PIN_GET_DIRECTION+0x82>
 250:	55 95       	asr	r21
 252:	47 95       	ror	r20
 254:	8a 95       	dec	r24
 256:	e2 f7       	brpl	.-8      	; 0x250 <GPIO_PIN_GET_DIRECTION+0x7e>
 258:	ca 01       	movw	r24, r20
 25a:	81 70       	andi	r24, 0x01	; 1
 25c:	ec 81       	ldd	r30, Y+4	; 0x04
 25e:	fd 81       	ldd	r31, Y+5	; 0x05
 260:	80 83       	st	Z, r24
	}
	return Retval;
 262:	89 81       	ldd	r24, Y+1	; 0x01
}
 264:	0f 90       	pop	r0
 266:	0f 90       	pop	r0
 268:	0f 90       	pop	r0
 26a:	0f 90       	pop	r0
 26c:	0f 90       	pop	r0
 26e:	cf 91       	pop	r28
 270:	df 91       	pop	r29
 272:	08 95       	ret

00000274 <GPIO_PIN_WRITE_LOGIC>:
#endif
#if GPIO_PIN_CFG == GPIO_CFG_ENABLE
Std_ReturnType GPIO_PIN_WRITE_LOGIC (const PIN_CFG_T *Pin,LOGIC_T LOG){
 274:	df 93       	push	r29
 276:	cf 93       	push	r28
 278:	00 d0       	rcall	.+0      	; 0x27a <GPIO_PIN_WRITE_LOGIC+0x6>
 27a:	00 d0       	rcall	.+0      	; 0x27c <GPIO_PIN_WRITE_LOGIC+0x8>
 27c:	00 d0       	rcall	.+0      	; 0x27e <GPIO_PIN_WRITE_LOGIC+0xa>
 27e:	cd b7       	in	r28, 0x3d	; 61
 280:	de b7       	in	r29, 0x3e	; 62
 282:	9b 83       	std	Y+3, r25	; 0x03
 284:	8a 83       	std	Y+2, r24	; 0x02
 286:	6c 83       	std	Y+4, r22	; 0x04
	Std_ReturnType Retval = E_OK;
 288:	81 e0       	ldi	r24, 0x01	; 1
 28a:	89 83       	std	Y+1, r24	; 0x01
	if(NULL == Pin || (Pin->PIN) >= (PORT_PIN_MAX)){
 28c:	8a 81       	ldd	r24, Y+2	; 0x02
 28e:	9b 81       	ldd	r25, Y+3	; 0x03
 290:	00 97       	sbiw	r24, 0x00	; 0
 292:	61 f0       	breq	.+24     	; 0x2ac <GPIO_PIN_WRITE_LOGIC+0x38>
 294:	ea 81       	ldd	r30, Y+2	; 0x02
 296:	fb 81       	ldd	r31, Y+3	; 0x03
 298:	80 81       	ld	r24, Z
 29a:	86 95       	lsr	r24
 29c:	86 95       	lsr	r24
 29e:	86 95       	lsr	r24
 2a0:	87 70       	andi	r24, 0x07	; 7
 2a2:	88 2f       	mov	r24, r24
 2a4:	90 e0       	ldi	r25, 0x00	; 0
 2a6:	88 30       	cpi	r24, 0x08	; 8
 2a8:	91 05       	cpc	r25, r1
 2aa:	14 f0       	brlt	.+4      	; 0x2b0 <GPIO_PIN_WRITE_LOGIC+0x3c>
		Retval = E_NOT_OK;
 2ac:	19 82       	std	Y+1, r1	; 0x01
 2ae:	73 c0       	rjmp	.+230    	; 0x396 <GPIO_PIN_WRITE_LOGIC+0x122>
	}
	else{
		switch(LOG){
 2b0:	8c 81       	ldd	r24, Y+4	; 0x04
 2b2:	28 2f       	mov	r18, r24
 2b4:	30 e0       	ldi	r19, 0x00	; 0
 2b6:	3e 83       	std	Y+6, r19	; 0x06
 2b8:	2d 83       	std	Y+5, r18	; 0x05
 2ba:	8d 81       	ldd	r24, Y+5	; 0x05
 2bc:	9e 81       	ldd	r25, Y+6	; 0x06
 2be:	00 97       	sbiw	r24, 0x00	; 0
 2c0:	31 f0       	breq	.+12     	; 0x2ce <GPIO_PIN_WRITE_LOGIC+0x5a>
 2c2:	2d 81       	ldd	r18, Y+5	; 0x05
 2c4:	3e 81       	ldd	r19, Y+6	; 0x06
 2c6:	21 30       	cpi	r18, 0x01	; 1
 2c8:	31 05       	cpc	r19, r1
 2ca:	99 f1       	breq	.+102    	; 0x332 <GPIO_PIN_WRITE_LOGIC+0xbe>
 2cc:	63 c0       	rjmp	.+198    	; 0x394 <GPIO_PIN_WRITE_LOGIC+0x120>
		case GPIO_LOW:
			CLEAR_BIT(*(PORT_REG[Pin->PORT]),Pin->PIN);
 2ce:	ea 81       	ldd	r30, Y+2	; 0x02
 2d0:	fb 81       	ldd	r31, Y+3	; 0x03
 2d2:	80 81       	ld	r24, Z
 2d4:	87 70       	andi	r24, 0x07	; 7
 2d6:	88 2f       	mov	r24, r24
 2d8:	90 e0       	ldi	r25, 0x00	; 0
 2da:	88 0f       	add	r24, r24
 2dc:	99 1f       	adc	r25, r25
 2de:	fc 01       	movw	r30, r24
 2e0:	e0 59       	subi	r30, 0x90	; 144
 2e2:	ff 4f       	sbci	r31, 0xFF	; 255
 2e4:	a0 81       	ld	r26, Z
 2e6:	b1 81       	ldd	r27, Z+1	; 0x01
 2e8:	ea 81       	ldd	r30, Y+2	; 0x02
 2ea:	fb 81       	ldd	r31, Y+3	; 0x03
 2ec:	80 81       	ld	r24, Z
 2ee:	87 70       	andi	r24, 0x07	; 7
 2f0:	88 2f       	mov	r24, r24
 2f2:	90 e0       	ldi	r25, 0x00	; 0
 2f4:	88 0f       	add	r24, r24
 2f6:	99 1f       	adc	r25, r25
 2f8:	fc 01       	movw	r30, r24
 2fa:	e0 59       	subi	r30, 0x90	; 144
 2fc:	ff 4f       	sbci	r31, 0xFF	; 255
 2fe:	01 90       	ld	r0, Z+
 300:	f0 81       	ld	r31, Z
 302:	e0 2d       	mov	r30, r0
 304:	80 81       	ld	r24, Z
 306:	48 2f       	mov	r20, r24
 308:	ea 81       	ldd	r30, Y+2	; 0x02
 30a:	fb 81       	ldd	r31, Y+3	; 0x03
 30c:	80 81       	ld	r24, Z
 30e:	86 95       	lsr	r24
 310:	86 95       	lsr	r24
 312:	86 95       	lsr	r24
 314:	87 70       	andi	r24, 0x07	; 7
 316:	28 2f       	mov	r18, r24
 318:	30 e0       	ldi	r19, 0x00	; 0
 31a:	81 e0       	ldi	r24, 0x01	; 1
 31c:	90 e0       	ldi	r25, 0x00	; 0
 31e:	02 2e       	mov	r0, r18
 320:	02 c0       	rjmp	.+4      	; 0x326 <GPIO_PIN_WRITE_LOGIC+0xb2>
 322:	88 0f       	add	r24, r24
 324:	99 1f       	adc	r25, r25
 326:	0a 94       	dec	r0
 328:	e2 f7       	brpl	.-8      	; 0x322 <GPIO_PIN_WRITE_LOGIC+0xae>
 32a:	80 95       	com	r24
 32c:	84 23       	and	r24, r20
 32e:	8c 93       	st	X, r24
 330:	32 c0       	rjmp	.+100    	; 0x396 <GPIO_PIN_WRITE_LOGIC+0x122>
			break;
		case GPIO_HIGH:
			SET_BIT(*(PORT_REG[Pin->PORT]),Pin->PIN);
 332:	ea 81       	ldd	r30, Y+2	; 0x02
 334:	fb 81       	ldd	r31, Y+3	; 0x03
 336:	80 81       	ld	r24, Z
 338:	87 70       	andi	r24, 0x07	; 7
 33a:	88 2f       	mov	r24, r24
 33c:	90 e0       	ldi	r25, 0x00	; 0
 33e:	88 0f       	add	r24, r24
 340:	99 1f       	adc	r25, r25
 342:	fc 01       	movw	r30, r24
 344:	e0 59       	subi	r30, 0x90	; 144
 346:	ff 4f       	sbci	r31, 0xFF	; 255
 348:	a0 81       	ld	r26, Z
 34a:	b1 81       	ldd	r27, Z+1	; 0x01
 34c:	ea 81       	ldd	r30, Y+2	; 0x02
 34e:	fb 81       	ldd	r31, Y+3	; 0x03
 350:	80 81       	ld	r24, Z
 352:	87 70       	andi	r24, 0x07	; 7
 354:	88 2f       	mov	r24, r24
 356:	90 e0       	ldi	r25, 0x00	; 0
 358:	88 0f       	add	r24, r24
 35a:	99 1f       	adc	r25, r25
 35c:	fc 01       	movw	r30, r24
 35e:	e0 59       	subi	r30, 0x90	; 144
 360:	ff 4f       	sbci	r31, 0xFF	; 255
 362:	01 90       	ld	r0, Z+
 364:	f0 81       	ld	r31, Z
 366:	e0 2d       	mov	r30, r0
 368:	80 81       	ld	r24, Z
 36a:	48 2f       	mov	r20, r24
 36c:	ea 81       	ldd	r30, Y+2	; 0x02
 36e:	fb 81       	ldd	r31, Y+3	; 0x03
 370:	80 81       	ld	r24, Z
 372:	86 95       	lsr	r24
 374:	86 95       	lsr	r24
 376:	86 95       	lsr	r24
 378:	87 70       	andi	r24, 0x07	; 7
 37a:	28 2f       	mov	r18, r24
 37c:	30 e0       	ldi	r19, 0x00	; 0
 37e:	81 e0       	ldi	r24, 0x01	; 1
 380:	90 e0       	ldi	r25, 0x00	; 0
 382:	02 2e       	mov	r0, r18
 384:	02 c0       	rjmp	.+4      	; 0x38a <GPIO_PIN_WRITE_LOGIC+0x116>
 386:	88 0f       	add	r24, r24
 388:	99 1f       	adc	r25, r25
 38a:	0a 94       	dec	r0
 38c:	e2 f7       	brpl	.-8      	; 0x386 <GPIO_PIN_WRITE_LOGIC+0x112>
 38e:	84 2b       	or	r24, r20
 390:	8c 93       	st	X, r24
 392:	01 c0       	rjmp	.+2      	; 0x396 <GPIO_PIN_WRITE_LOGIC+0x122>
			break;
		default:
			Retval = E_NOT_OK;
 394:	19 82       	std	Y+1, r1	; 0x01
			break;
		}
	}
	return Retval;
 396:	89 81       	ldd	r24, Y+1	; 0x01
}
 398:	26 96       	adiw	r28, 0x06	; 6
 39a:	0f b6       	in	r0, 0x3f	; 63
 39c:	f8 94       	cli
 39e:	de bf       	out	0x3e, r29	; 62
 3a0:	0f be       	out	0x3f, r0	; 63
 3a2:	cd bf       	out	0x3d, r28	; 61
 3a4:	cf 91       	pop	r28
 3a6:	df 91       	pop	r29
 3a8:	08 95       	ret

000003aa <GPIO_PIN_READ_LOGIC>:
#endif
#if GPIO_PIN_CFG == GPIO_CFG_ENABLE
Std_ReturnType GPIO_PIN_READ_LOGIC (const PIN_CFG_T *Pin,LOGIC_T *LOG){
 3aa:	df 93       	push	r29
 3ac:	cf 93       	push	r28
 3ae:	00 d0       	rcall	.+0      	; 0x3b0 <GPIO_PIN_READ_LOGIC+0x6>
 3b0:	00 d0       	rcall	.+0      	; 0x3b2 <GPIO_PIN_READ_LOGIC+0x8>
 3b2:	0f 92       	push	r0
 3b4:	cd b7       	in	r28, 0x3d	; 61
 3b6:	de b7       	in	r29, 0x3e	; 62
 3b8:	9b 83       	std	Y+3, r25	; 0x03
 3ba:	8a 83       	std	Y+2, r24	; 0x02
 3bc:	7d 83       	std	Y+5, r23	; 0x05
 3be:	6c 83       	std	Y+4, r22	; 0x04
	Std_ReturnType Retval = E_OK;
 3c0:	81 e0       	ldi	r24, 0x01	; 1
 3c2:	89 83       	std	Y+1, r24	; 0x01
	if(NULL == Pin || (Pin->PIN) >= (PORT_PIN_MAX) || NULL == LOG){
 3c4:	8a 81       	ldd	r24, Y+2	; 0x02
 3c6:	9b 81       	ldd	r25, Y+3	; 0x03
 3c8:	00 97       	sbiw	r24, 0x00	; 0
 3ca:	81 f0       	breq	.+32     	; 0x3ec <GPIO_PIN_READ_LOGIC+0x42>
 3cc:	ea 81       	ldd	r30, Y+2	; 0x02
 3ce:	fb 81       	ldd	r31, Y+3	; 0x03
 3d0:	80 81       	ld	r24, Z
 3d2:	86 95       	lsr	r24
 3d4:	86 95       	lsr	r24
 3d6:	86 95       	lsr	r24
 3d8:	87 70       	andi	r24, 0x07	; 7
 3da:	88 2f       	mov	r24, r24
 3dc:	90 e0       	ldi	r25, 0x00	; 0
 3de:	88 30       	cpi	r24, 0x08	; 8
 3e0:	91 05       	cpc	r25, r1
 3e2:	24 f4       	brge	.+8      	; 0x3ec <GPIO_PIN_READ_LOGIC+0x42>
 3e4:	8c 81       	ldd	r24, Y+4	; 0x04
 3e6:	9d 81       	ldd	r25, Y+5	; 0x05
 3e8:	00 97       	sbiw	r24, 0x00	; 0
 3ea:	11 f4       	brne	.+4      	; 0x3f0 <GPIO_PIN_READ_LOGIC+0x46>
		Retval = E_NOT_OK;
 3ec:	19 82       	std	Y+1, r1	; 0x01
 3ee:	25 c0       	rjmp	.+74     	; 0x43a <GPIO_PIN_READ_LOGIC+0x90>
	}
	else{
		*LOG  = READ_BIT(*(PIN_REG[Pin->PORT]),Pin->PIN);
 3f0:	ea 81       	ldd	r30, Y+2	; 0x02
 3f2:	fb 81       	ldd	r31, Y+3	; 0x03
 3f4:	80 81       	ld	r24, Z
 3f6:	87 70       	andi	r24, 0x07	; 7
 3f8:	88 2f       	mov	r24, r24
 3fa:	90 e0       	ldi	r25, 0x00	; 0
 3fc:	88 0f       	add	r24, r24
 3fe:	99 1f       	adc	r25, r25
 400:	fc 01       	movw	r30, r24
 402:	e8 59       	subi	r30, 0x98	; 152
 404:	ff 4f       	sbci	r31, 0xFF	; 255
 406:	01 90       	ld	r0, Z+
 408:	f0 81       	ld	r31, Z
 40a:	e0 2d       	mov	r30, r0
 40c:	80 81       	ld	r24, Z
 40e:	28 2f       	mov	r18, r24
 410:	30 e0       	ldi	r19, 0x00	; 0
 412:	ea 81       	ldd	r30, Y+2	; 0x02
 414:	fb 81       	ldd	r31, Y+3	; 0x03
 416:	80 81       	ld	r24, Z
 418:	86 95       	lsr	r24
 41a:	86 95       	lsr	r24
 41c:	86 95       	lsr	r24
 41e:	87 70       	andi	r24, 0x07	; 7
 420:	88 2f       	mov	r24, r24
 422:	90 e0       	ldi	r25, 0x00	; 0
 424:	a9 01       	movw	r20, r18
 426:	02 c0       	rjmp	.+4      	; 0x42c <GPIO_PIN_READ_LOGIC+0x82>
 428:	55 95       	asr	r21
 42a:	47 95       	ror	r20
 42c:	8a 95       	dec	r24
 42e:	e2 f7       	brpl	.-8      	; 0x428 <GPIO_PIN_READ_LOGIC+0x7e>
 430:	ca 01       	movw	r24, r20
 432:	81 70       	andi	r24, 0x01	; 1
 434:	ec 81       	ldd	r30, Y+4	; 0x04
 436:	fd 81       	ldd	r31, Y+5	; 0x05
 438:	80 83       	st	Z, r24
	}
	return Retval;
 43a:	89 81       	ldd	r24, Y+1	; 0x01
}
 43c:	0f 90       	pop	r0
 43e:	0f 90       	pop	r0
 440:	0f 90       	pop	r0
 442:	0f 90       	pop	r0
 444:	0f 90       	pop	r0
 446:	cf 91       	pop	r28
 448:	df 91       	pop	r29
 44a:	08 95       	ret

0000044c <GPIO_PIN_TOGGLE_LOGIC>:
#endif
#if GPIO_PIN_CFG == GPIO_CFG_ENABLE
Std_ReturnType GPIO_PIN_TOGGLE_LOGIC (const PIN_CFG_T *Pin){
 44c:	df 93       	push	r29
 44e:	cf 93       	push	r28
 450:	00 d0       	rcall	.+0      	; 0x452 <GPIO_PIN_TOGGLE_LOGIC+0x6>
 452:	0f 92       	push	r0
 454:	cd b7       	in	r28, 0x3d	; 61
 456:	de b7       	in	r29, 0x3e	; 62
 458:	9b 83       	std	Y+3, r25	; 0x03
 45a:	8a 83       	std	Y+2, r24	; 0x02
	Std_ReturnType Retval = E_OK;
 45c:	81 e0       	ldi	r24, 0x01	; 1
 45e:	89 83       	std	Y+1, r24	; 0x01
	if(NULL == Pin || (Pin->PIN) >= (PORT_PIN_MAX)){
 460:	8a 81       	ldd	r24, Y+2	; 0x02
 462:	9b 81       	ldd	r25, Y+3	; 0x03
 464:	00 97       	sbiw	r24, 0x00	; 0
 466:	61 f0       	breq	.+24     	; 0x480 <GPIO_PIN_TOGGLE_LOGIC+0x34>
 468:	ea 81       	ldd	r30, Y+2	; 0x02
 46a:	fb 81       	ldd	r31, Y+3	; 0x03
 46c:	80 81       	ld	r24, Z
 46e:	86 95       	lsr	r24
 470:	86 95       	lsr	r24
 472:	86 95       	lsr	r24
 474:	87 70       	andi	r24, 0x07	; 7
 476:	88 2f       	mov	r24, r24
 478:	90 e0       	ldi	r25, 0x00	; 0
 47a:	88 30       	cpi	r24, 0x08	; 8
 47c:	91 05       	cpc	r25, r1
 47e:	14 f0       	brlt	.+4      	; 0x484 <GPIO_PIN_TOGGLE_LOGIC+0x38>
		Retval = E_NOT_OK;
 480:	19 82       	std	Y+1, r1	; 0x01
 482:	30 c0       	rjmp	.+96     	; 0x4e4 <GPIO_PIN_TOGGLE_LOGIC+0x98>
	}
	else{
		TOGGLE_BIT(*(PORT_REG[Pin->PORT]),Pin->PIN);
 484:	ea 81       	ldd	r30, Y+2	; 0x02
 486:	fb 81       	ldd	r31, Y+3	; 0x03
 488:	80 81       	ld	r24, Z
 48a:	87 70       	andi	r24, 0x07	; 7
 48c:	88 2f       	mov	r24, r24
 48e:	90 e0       	ldi	r25, 0x00	; 0
 490:	88 0f       	add	r24, r24
 492:	99 1f       	adc	r25, r25
 494:	fc 01       	movw	r30, r24
 496:	e0 59       	subi	r30, 0x90	; 144
 498:	ff 4f       	sbci	r31, 0xFF	; 255
 49a:	a0 81       	ld	r26, Z
 49c:	b1 81       	ldd	r27, Z+1	; 0x01
 49e:	ea 81       	ldd	r30, Y+2	; 0x02
 4a0:	fb 81       	ldd	r31, Y+3	; 0x03
 4a2:	80 81       	ld	r24, Z
 4a4:	87 70       	andi	r24, 0x07	; 7
 4a6:	88 2f       	mov	r24, r24
 4a8:	90 e0       	ldi	r25, 0x00	; 0
 4aa:	88 0f       	add	r24, r24
 4ac:	99 1f       	adc	r25, r25
 4ae:	fc 01       	movw	r30, r24
 4b0:	e0 59       	subi	r30, 0x90	; 144
 4b2:	ff 4f       	sbci	r31, 0xFF	; 255
 4b4:	01 90       	ld	r0, Z+
 4b6:	f0 81       	ld	r31, Z
 4b8:	e0 2d       	mov	r30, r0
 4ba:	80 81       	ld	r24, Z
 4bc:	48 2f       	mov	r20, r24
 4be:	ea 81       	ldd	r30, Y+2	; 0x02
 4c0:	fb 81       	ldd	r31, Y+3	; 0x03
 4c2:	80 81       	ld	r24, Z
 4c4:	86 95       	lsr	r24
 4c6:	86 95       	lsr	r24
 4c8:	86 95       	lsr	r24
 4ca:	87 70       	andi	r24, 0x07	; 7
 4cc:	28 2f       	mov	r18, r24
 4ce:	30 e0       	ldi	r19, 0x00	; 0
 4d0:	81 e0       	ldi	r24, 0x01	; 1
 4d2:	90 e0       	ldi	r25, 0x00	; 0
 4d4:	02 2e       	mov	r0, r18
 4d6:	02 c0       	rjmp	.+4      	; 0x4dc <GPIO_PIN_TOGGLE_LOGIC+0x90>
 4d8:	88 0f       	add	r24, r24
 4da:	99 1f       	adc	r25, r25
 4dc:	0a 94       	dec	r0
 4de:	e2 f7       	brpl	.-8      	; 0x4d8 <GPIO_PIN_TOGGLE_LOGIC+0x8c>
 4e0:	84 27       	eor	r24, r20
 4e2:	8c 93       	st	X, r24
	}
	return Retval;
 4e4:	89 81       	ldd	r24, Y+1	; 0x01
}
 4e6:	0f 90       	pop	r0
 4e8:	0f 90       	pop	r0
 4ea:	0f 90       	pop	r0
 4ec:	cf 91       	pop	r28
 4ee:	df 91       	pop	r29
 4f0:	08 95       	ret

000004f2 <GPIO_PIN_INITIALIZE>:
#endif
#if GPIO_PIN_CFG == GPIO_CFG_ENABLE
Std_ReturnType GPIO_PIN_INITIALIZE (const PIN_CFG_T *Pin){
 4f2:	df 93       	push	r29
 4f4:	cf 93       	push	r28
 4f6:	00 d0       	rcall	.+0      	; 0x4f8 <GPIO_PIN_INITIALIZE+0x6>
 4f8:	0f 92       	push	r0
 4fa:	cd b7       	in	r28, 0x3d	; 61
 4fc:	de b7       	in	r29, 0x3e	; 62
 4fe:	9b 83       	std	Y+3, r25	; 0x03
 500:	8a 83       	std	Y+2, r24	; 0x02
	Std_ReturnType Retval = E_OK;
 502:	81 e0       	ldi	r24, 0x01	; 1
 504:	89 83       	std	Y+1, r24	; 0x01
	if(NULL == Pin || (Pin->PIN) >= (PORT_PIN_MAX)){
 506:	8a 81       	ldd	r24, Y+2	; 0x02
 508:	9b 81       	ldd	r25, Y+3	; 0x03
 50a:	00 97       	sbiw	r24, 0x00	; 0
 50c:	61 f0       	breq	.+24     	; 0x526 <GPIO_PIN_INITIALIZE+0x34>
 50e:	ea 81       	ldd	r30, Y+2	; 0x02
 510:	fb 81       	ldd	r31, Y+3	; 0x03
 512:	80 81       	ld	r24, Z
 514:	86 95       	lsr	r24
 516:	86 95       	lsr	r24
 518:	86 95       	lsr	r24
 51a:	87 70       	andi	r24, 0x07	; 7
 51c:	88 2f       	mov	r24, r24
 51e:	90 e0       	ldi	r25, 0x00	; 0
 520:	88 30       	cpi	r24, 0x08	; 8
 522:	91 05       	cpc	r25, r1
 524:	14 f0       	brlt	.+4      	; 0x52a <GPIO_PIN_INITIALIZE+0x38>
		Retval = E_NOT_OK;
 526:	19 82       	std	Y+1, r1	; 0x01
 528:	12 c0       	rjmp	.+36     	; 0x54e <GPIO_PIN_INITIALIZE+0x5c>
	}
	else{
		Retval = GPIO_PIN_DIRECTION_INITIALIZE(Pin);
 52a:	8a 81       	ldd	r24, Y+2	; 0x02
 52c:	9b 81       	ldd	r25, Y+3	; 0x03
 52e:	0e 94 49 00 	call	0x92	; 0x92 <GPIO_PIN_DIRECTION_INITIALIZE>
 532:	89 83       	std	Y+1, r24	; 0x01
		Retval = GPIO_PIN_WRITE_LOGIC(Pin,Pin->LOGIC);
 534:	ea 81       	ldd	r30, Y+2	; 0x02
 536:	fb 81       	ldd	r31, Y+3	; 0x03
 538:	80 81       	ld	r24, Z
 53a:	88 1f       	adc	r24, r24
 53c:	88 27       	eor	r24, r24
 53e:	88 1f       	adc	r24, r24
 540:	28 2f       	mov	r18, r24
 542:	8a 81       	ldd	r24, Y+2	; 0x02
 544:	9b 81       	ldd	r25, Y+3	; 0x03
 546:	62 2f       	mov	r22, r18
 548:	0e 94 3a 01 	call	0x274	; 0x274 <GPIO_PIN_WRITE_LOGIC>
 54c:	89 83       	std	Y+1, r24	; 0x01
	}
	return Retval;
 54e:	89 81       	ldd	r24, Y+1	; 0x01
}
 550:	0f 90       	pop	r0
 552:	0f 90       	pop	r0
 554:	0f 90       	pop	r0
 556:	cf 91       	pop	r28
 558:	df 91       	pop	r29
 55a:	08 95       	ret

0000055c <GPIO_PORT_DIRECTION_INITIALIZE>:
#endif

						/*PORT Functions*/
#if GPIO_PORT_CFG == GPIO_CFG_ENABLE
Std_ReturnType GPIO_PORT_DIRECTION_INITIALIZE (PORT_T PORT,uint8 DIR){
 55c:	df 93       	push	r29
 55e:	cf 93       	push	r28
 560:	00 d0       	rcall	.+0      	; 0x562 <GPIO_PORT_DIRECTION_INITIALIZE+0x6>
 562:	0f 92       	push	r0
 564:	cd b7       	in	r28, 0x3d	; 61
 566:	de b7       	in	r29, 0x3e	; 62
 568:	8a 83       	std	Y+2, r24	; 0x02
 56a:	6b 83       	std	Y+3, r22	; 0x03
	Std_ReturnType Retval = E_OK;
 56c:	81 e0       	ldi	r24, 0x01	; 1
 56e:	89 83       	std	Y+1, r24	; 0x01
	if(PORT >= (PORT_MAX)){
 570:	8a 81       	ldd	r24, Y+2	; 0x02
 572:	84 30       	cpi	r24, 0x04	; 4
 574:	10 f0       	brcs	.+4      	; 0x57a <GPIO_PORT_DIRECTION_INITIALIZE+0x1e>
		Retval = E_NOT_OK;
 576:	19 82       	std	Y+1, r1	; 0x01
 578:	0d c0       	rjmp	.+26     	; 0x594 <GPIO_PORT_DIRECTION_INITIALIZE+0x38>
	}
	else{
		*(DDR_REG[PORT]) = DIR;
 57a:	8a 81       	ldd	r24, Y+2	; 0x02
 57c:	88 2f       	mov	r24, r24
 57e:	90 e0       	ldi	r25, 0x00	; 0
 580:	88 0f       	add	r24, r24
 582:	99 1f       	adc	r25, r25
 584:	fc 01       	movw	r30, r24
 586:	e0 5a       	subi	r30, 0xA0	; 160
 588:	ff 4f       	sbci	r31, 0xFF	; 255
 58a:	01 90       	ld	r0, Z+
 58c:	f0 81       	ld	r31, Z
 58e:	e0 2d       	mov	r30, r0
 590:	8b 81       	ldd	r24, Y+3	; 0x03
 592:	80 83       	st	Z, r24
	}
	return Retval;
 594:	89 81       	ldd	r24, Y+1	; 0x01
}
 596:	0f 90       	pop	r0
 598:	0f 90       	pop	r0
 59a:	0f 90       	pop	r0
 59c:	cf 91       	pop	r28
 59e:	df 91       	pop	r29
 5a0:	08 95       	ret

000005a2 <GPIO_PORT_GET_DIRECTION>:
#endif
#if GPIO_PORT_CFG == GPIO_CFG_ENABLE
Std_ReturnType GPIO_PORT_GET_DIRECTION (PORT_T PORT ,uint8 *DIR){
 5a2:	df 93       	push	r29
 5a4:	cf 93       	push	r28
 5a6:	00 d0       	rcall	.+0      	; 0x5a8 <GPIO_PORT_GET_DIRECTION+0x6>
 5a8:	00 d0       	rcall	.+0      	; 0x5aa <GPIO_PORT_GET_DIRECTION+0x8>
 5aa:	cd b7       	in	r28, 0x3d	; 61
 5ac:	de b7       	in	r29, 0x3e	; 62
 5ae:	8a 83       	std	Y+2, r24	; 0x02
 5b0:	7c 83       	std	Y+4, r23	; 0x04
 5b2:	6b 83       	std	Y+3, r22	; 0x03
	Std_ReturnType Retval = E_OK;
 5b4:	81 e0       	ldi	r24, 0x01	; 1
 5b6:	89 83       	std	Y+1, r24	; 0x01
	if(PORT >= (PORT_MAX) || NULL == DIR){
 5b8:	8a 81       	ldd	r24, Y+2	; 0x02
 5ba:	84 30       	cpi	r24, 0x04	; 4
 5bc:	20 f4       	brcc	.+8      	; 0x5c6 <GPIO_PORT_GET_DIRECTION+0x24>
 5be:	8b 81       	ldd	r24, Y+3	; 0x03
 5c0:	9c 81       	ldd	r25, Y+4	; 0x04
 5c2:	00 97       	sbiw	r24, 0x00	; 0
 5c4:	11 f4       	brne	.+4      	; 0x5ca <GPIO_PORT_GET_DIRECTION+0x28>
		Retval = E_NOT_OK;
 5c6:	19 82       	std	Y+1, r1	; 0x01
 5c8:	0f c0       	rjmp	.+30     	; 0x5e8 <GPIO_PORT_GET_DIRECTION+0x46>
	}
	else{
		*DIR = *(DDR_REG[PORT]);
 5ca:	8a 81       	ldd	r24, Y+2	; 0x02
 5cc:	88 2f       	mov	r24, r24
 5ce:	90 e0       	ldi	r25, 0x00	; 0
 5d0:	88 0f       	add	r24, r24
 5d2:	99 1f       	adc	r25, r25
 5d4:	fc 01       	movw	r30, r24
 5d6:	e0 5a       	subi	r30, 0xA0	; 160
 5d8:	ff 4f       	sbci	r31, 0xFF	; 255
 5da:	01 90       	ld	r0, Z+
 5dc:	f0 81       	ld	r31, Z
 5de:	e0 2d       	mov	r30, r0
 5e0:	80 81       	ld	r24, Z
 5e2:	eb 81       	ldd	r30, Y+3	; 0x03
 5e4:	fc 81       	ldd	r31, Y+4	; 0x04
 5e6:	80 83       	st	Z, r24
	}
	return Retval;
 5e8:	89 81       	ldd	r24, Y+1	; 0x01
}
 5ea:	0f 90       	pop	r0
 5ec:	0f 90       	pop	r0
 5ee:	0f 90       	pop	r0
 5f0:	0f 90       	pop	r0
 5f2:	cf 91       	pop	r28
 5f4:	df 91       	pop	r29
 5f6:	08 95       	ret

000005f8 <GPIO_PORT_WRITE_LOGIC>:
#endif
#if GPIO_PORT_CFG == GPIO_CFG_ENABLE
Std_ReturnType GPIO_PORT_WRITE_LOGIC (PORT_T PORT,uint8 LOG){
 5f8:	df 93       	push	r29
 5fa:	cf 93       	push	r28
 5fc:	00 d0       	rcall	.+0      	; 0x5fe <GPIO_PORT_WRITE_LOGIC+0x6>
 5fe:	0f 92       	push	r0
 600:	cd b7       	in	r28, 0x3d	; 61
 602:	de b7       	in	r29, 0x3e	; 62
 604:	8a 83       	std	Y+2, r24	; 0x02
 606:	6b 83       	std	Y+3, r22	; 0x03
	Std_ReturnType Retval = E_OK;
 608:	81 e0       	ldi	r24, 0x01	; 1
 60a:	89 83       	std	Y+1, r24	; 0x01
	if(PORT >= (PORT_MAX)){
 60c:	8a 81       	ldd	r24, Y+2	; 0x02
 60e:	84 30       	cpi	r24, 0x04	; 4
 610:	10 f0       	brcs	.+4      	; 0x616 <GPIO_PORT_WRITE_LOGIC+0x1e>
		Retval = E_NOT_OK;
 612:	19 82       	std	Y+1, r1	; 0x01
 614:	0d c0       	rjmp	.+26     	; 0x630 <GPIO_PORT_WRITE_LOGIC+0x38>
	}
	else{
		*(PORT_REG[PORT]) = LOG;
 616:	8a 81       	ldd	r24, Y+2	; 0x02
 618:	88 2f       	mov	r24, r24
 61a:	90 e0       	ldi	r25, 0x00	; 0
 61c:	88 0f       	add	r24, r24
 61e:	99 1f       	adc	r25, r25
 620:	fc 01       	movw	r30, r24
 622:	e0 59       	subi	r30, 0x90	; 144
 624:	ff 4f       	sbci	r31, 0xFF	; 255
 626:	01 90       	ld	r0, Z+
 628:	f0 81       	ld	r31, Z
 62a:	e0 2d       	mov	r30, r0
 62c:	8b 81       	ldd	r24, Y+3	; 0x03
 62e:	80 83       	st	Z, r24
	}
	return Retval;
 630:	89 81       	ldd	r24, Y+1	; 0x01
}
 632:	0f 90       	pop	r0
 634:	0f 90       	pop	r0
 636:	0f 90       	pop	r0
 638:	cf 91       	pop	r28
 63a:	df 91       	pop	r29
 63c:	08 95       	ret

0000063e <GPIO_PORT_READ_LOGIC>:
#endif
#if GPIO_PORT_CFG == GPIO_CFG_ENABLE
Std_ReturnType GPIO_PORT_READ_LOGIC (PORT_T PORT,uint8 *LOG){
 63e:	df 93       	push	r29
 640:	cf 93       	push	r28
 642:	00 d0       	rcall	.+0      	; 0x644 <GPIO_PORT_READ_LOGIC+0x6>
 644:	00 d0       	rcall	.+0      	; 0x646 <GPIO_PORT_READ_LOGIC+0x8>
 646:	cd b7       	in	r28, 0x3d	; 61
 648:	de b7       	in	r29, 0x3e	; 62
 64a:	8a 83       	std	Y+2, r24	; 0x02
 64c:	7c 83       	std	Y+4, r23	; 0x04
 64e:	6b 83       	std	Y+3, r22	; 0x03
	Std_ReturnType Retval = E_OK;
 650:	81 e0       	ldi	r24, 0x01	; 1
 652:	89 83       	std	Y+1, r24	; 0x01
	if(PORT >= (PORT_MAX) || NULL == LOG){
 654:	8a 81       	ldd	r24, Y+2	; 0x02
 656:	84 30       	cpi	r24, 0x04	; 4
 658:	20 f4       	brcc	.+8      	; 0x662 <GPIO_PORT_READ_LOGIC+0x24>
 65a:	8b 81       	ldd	r24, Y+3	; 0x03
 65c:	9c 81       	ldd	r25, Y+4	; 0x04
 65e:	00 97       	sbiw	r24, 0x00	; 0
 660:	11 f4       	brne	.+4      	; 0x666 <GPIO_PORT_READ_LOGIC+0x28>
		Retval = E_NOT_OK;
 662:	19 82       	std	Y+1, r1	; 0x01
 664:	0f c0       	rjmp	.+30     	; 0x684 <GPIO_PORT_READ_LOGIC+0x46>
	}
	else{
		*LOG = *(PORT_REG[PORT]);
 666:	8a 81       	ldd	r24, Y+2	; 0x02
 668:	88 2f       	mov	r24, r24
 66a:	90 e0       	ldi	r25, 0x00	; 0
 66c:	88 0f       	add	r24, r24
 66e:	99 1f       	adc	r25, r25
 670:	fc 01       	movw	r30, r24
 672:	e0 59       	subi	r30, 0x90	; 144
 674:	ff 4f       	sbci	r31, 0xFF	; 255
 676:	01 90       	ld	r0, Z+
 678:	f0 81       	ld	r31, Z
 67a:	e0 2d       	mov	r30, r0
 67c:	80 81       	ld	r24, Z
 67e:	eb 81       	ldd	r30, Y+3	; 0x03
 680:	fc 81       	ldd	r31, Y+4	; 0x04
 682:	80 83       	st	Z, r24
	}
	return Retval;
 684:	89 81       	ldd	r24, Y+1	; 0x01
}
 686:	0f 90       	pop	r0
 688:	0f 90       	pop	r0
 68a:	0f 90       	pop	r0
 68c:	0f 90       	pop	r0
 68e:	cf 91       	pop	r28
 690:	df 91       	pop	r29
 692:	08 95       	ret

00000694 <GPIO_PORT_TOGGLE_LOGIC>:
#endif
#if GPIO_PORT_CFG == GPIO_CFG_ENABLE
Std_ReturnType GPIO_PORT_TOGGLE_LOGIC (PORT_T PORT){
 694:	df 93       	push	r29
 696:	cf 93       	push	r28
 698:	00 d0       	rcall	.+0      	; 0x69a <GPIO_PORT_TOGGLE_LOGIC+0x6>
 69a:	cd b7       	in	r28, 0x3d	; 61
 69c:	de b7       	in	r29, 0x3e	; 62
 69e:	8a 83       	std	Y+2, r24	; 0x02
	Std_ReturnType Retval = E_OK;
 6a0:	81 e0       	ldi	r24, 0x01	; 1
 6a2:	89 83       	std	Y+1, r24	; 0x01
	if(PORT >= (PORT_MAX)){
 6a4:	8a 81       	ldd	r24, Y+2	; 0x02
 6a6:	84 30       	cpi	r24, 0x04	; 4
 6a8:	10 f0       	brcs	.+4      	; 0x6ae <GPIO_PORT_TOGGLE_LOGIC+0x1a>
		Retval = E_NOT_OK;
 6aa:	19 82       	std	Y+1, r1	; 0x01
 6ac:	18 c0       	rjmp	.+48     	; 0x6de <GPIO_PORT_TOGGLE_LOGIC+0x4a>
	}
	else{
		*(PORT_REG[PORT]) ^= PORT_MASK;
 6ae:	8a 81       	ldd	r24, Y+2	; 0x02
 6b0:	88 2f       	mov	r24, r24
 6b2:	90 e0       	ldi	r25, 0x00	; 0
 6b4:	88 0f       	add	r24, r24
 6b6:	99 1f       	adc	r25, r25
 6b8:	fc 01       	movw	r30, r24
 6ba:	e0 59       	subi	r30, 0x90	; 144
 6bc:	ff 4f       	sbci	r31, 0xFF	; 255
 6be:	a0 81       	ld	r26, Z
 6c0:	b1 81       	ldd	r27, Z+1	; 0x01
 6c2:	8a 81       	ldd	r24, Y+2	; 0x02
 6c4:	88 2f       	mov	r24, r24
 6c6:	90 e0       	ldi	r25, 0x00	; 0
 6c8:	88 0f       	add	r24, r24
 6ca:	99 1f       	adc	r25, r25
 6cc:	fc 01       	movw	r30, r24
 6ce:	e0 59       	subi	r30, 0x90	; 144
 6d0:	ff 4f       	sbci	r31, 0xFF	; 255
 6d2:	01 90       	ld	r0, Z+
 6d4:	f0 81       	ld	r31, Z
 6d6:	e0 2d       	mov	r30, r0
 6d8:	80 81       	ld	r24, Z
 6da:	80 95       	com	r24
 6dc:	8c 93       	st	X, r24
	}
	return Retval;
 6de:	89 81       	ldd	r24, Y+1	; 0x01
}
 6e0:	0f 90       	pop	r0
 6e2:	0f 90       	pop	r0
 6e4:	cf 91       	pop	r28
 6e6:	df 91       	pop	r29
 6e8:	08 95       	ret

000006ea <RELAY_INITIALIZE>:
 */


#include "ECU_RELAY.h"

Std_ReturnType RELAY_INITIALIZE (const RELAY_T *relay){
 6ea:	df 93       	push	r29
 6ec:	cf 93       	push	r28
 6ee:	00 d0       	rcall	.+0      	; 0x6f0 <RELAY_INITIALIZE+0x6>
 6f0:	0f 92       	push	r0
 6f2:	cd b7       	in	r28, 0x3d	; 61
 6f4:	de b7       	in	r29, 0x3e	; 62
 6f6:	9b 83       	std	Y+3, r25	; 0x03
 6f8:	8a 83       	std	Y+2, r24	; 0x02
	Std_ReturnType Retval = E_OK;
 6fa:	81 e0       	ldi	r24, 0x01	; 1
 6fc:	89 83       	std	Y+1, r24	; 0x01
	if(NULL == relay){
 6fe:	8a 81       	ldd	r24, Y+2	; 0x02
 700:	9b 81       	ldd	r25, Y+3	; 0x03
 702:	00 97       	sbiw	r24, 0x00	; 0
 704:	11 f4       	brne	.+4      	; 0x70a <RELAY_INITIALIZE+0x20>
		Retval = E_NOT_OK;
 706:	19 82       	std	Y+1, r1	; 0x01
 708:	05 c0       	rjmp	.+10     	; 0x714 <RELAY_INITIALIZE+0x2a>
	}
	else{
		Retval = GPIO_PIN_INITIALIZE(&(relay->RELAY_PIN));
 70a:	8a 81       	ldd	r24, Y+2	; 0x02
 70c:	9b 81       	ldd	r25, Y+3	; 0x03
 70e:	0e 94 79 02 	call	0x4f2	; 0x4f2 <GPIO_PIN_INITIALIZE>
 712:	89 83       	std	Y+1, r24	; 0x01
	}
	return Retval;
 714:	89 81       	ldd	r24, Y+1	; 0x01
}
 716:	0f 90       	pop	r0
 718:	0f 90       	pop	r0
 71a:	0f 90       	pop	r0
 71c:	cf 91       	pop	r28
 71e:	df 91       	pop	r29
 720:	08 95       	ret

00000722 <RELAY_TURN_ON>:
Std_ReturnType RELAY_TURN_ON (const RELAY_T *relay){
 722:	df 93       	push	r29
 724:	cf 93       	push	r28
 726:	00 d0       	rcall	.+0      	; 0x728 <RELAY_TURN_ON+0x6>
 728:	00 d0       	rcall	.+0      	; 0x72a <RELAY_TURN_ON+0x8>
 72a:	cd b7       	in	r28, 0x3d	; 61
 72c:	de b7       	in	r29, 0x3e	; 62
 72e:	9c 83       	std	Y+4, r25	; 0x04
 730:	8b 83       	std	Y+3, r24	; 0x03
	Std_ReturnType Retval = E_OK;
 732:	81 e0       	ldi	r24, 0x01	; 1
 734:	8a 83       	std	Y+2, r24	; 0x02
	if(NULL == relay){
 736:	8b 81       	ldd	r24, Y+3	; 0x03
 738:	9c 81       	ldd	r25, Y+4	; 0x04
 73a:	00 97       	sbiw	r24, 0x00	; 0
 73c:	11 f4       	brne	.+4      	; 0x742 <RELAY_TURN_ON+0x20>
		Retval = E_NOT_OK;
 73e:	1a 82       	std	Y+2, r1	; 0x02
 740:	08 c0       	rjmp	.+16     	; 0x752 <RELAY_TURN_ON+0x30>
	}
	else{
		LOGIC_T log = (LOGIC_T)RELAY_ON;
 742:	81 e0       	ldi	r24, 0x01	; 1
 744:	89 83       	std	Y+1, r24	; 0x01
		Retval = GPIO_PIN_WRITE_LOGIC(&(relay->RELAY_PIN),log);
 746:	8b 81       	ldd	r24, Y+3	; 0x03
 748:	9c 81       	ldd	r25, Y+4	; 0x04
 74a:	69 81       	ldd	r22, Y+1	; 0x01
 74c:	0e 94 3a 01 	call	0x274	; 0x274 <GPIO_PIN_WRITE_LOGIC>
 750:	8a 83       	std	Y+2, r24	; 0x02
	}
	return Retval;
 752:	8a 81       	ldd	r24, Y+2	; 0x02
}
 754:	0f 90       	pop	r0
 756:	0f 90       	pop	r0
 758:	0f 90       	pop	r0
 75a:	0f 90       	pop	r0
 75c:	cf 91       	pop	r28
 75e:	df 91       	pop	r29
 760:	08 95       	ret

00000762 <RELAY_TURN_OFF>:
Std_ReturnType RELAY_TURN_OFF (const RELAY_T *relay){
 762:	df 93       	push	r29
 764:	cf 93       	push	r28
 766:	00 d0       	rcall	.+0      	; 0x768 <RELAY_TURN_OFF+0x6>
 768:	00 d0       	rcall	.+0      	; 0x76a <RELAY_TURN_OFF+0x8>
 76a:	cd b7       	in	r28, 0x3d	; 61
 76c:	de b7       	in	r29, 0x3e	; 62
 76e:	9c 83       	std	Y+4, r25	; 0x04
 770:	8b 83       	std	Y+3, r24	; 0x03
	Std_ReturnType Retval = E_OK;
 772:	81 e0       	ldi	r24, 0x01	; 1
 774:	8a 83       	std	Y+2, r24	; 0x02
	if(NULL == relay){
 776:	8b 81       	ldd	r24, Y+3	; 0x03
 778:	9c 81       	ldd	r25, Y+4	; 0x04
 77a:	00 97       	sbiw	r24, 0x00	; 0
 77c:	11 f4       	brne	.+4      	; 0x782 <RELAY_TURN_OFF+0x20>
		Retval = E_NOT_OK;
 77e:	1a 82       	std	Y+2, r1	; 0x02
 780:	07 c0       	rjmp	.+14     	; 0x790 <RELAY_TURN_OFF+0x2e>
	}
	else{
		LOGIC_T log = (LOGIC_T)RELAY_OFF;
 782:	19 82       	std	Y+1, r1	; 0x01
		Retval = GPIO_PIN_WRITE_LOGIC(&(relay->RELAY_PIN),log);
 784:	8b 81       	ldd	r24, Y+3	; 0x03
 786:	9c 81       	ldd	r25, Y+4	; 0x04
 788:	69 81       	ldd	r22, Y+1	; 0x01
 78a:	0e 94 3a 01 	call	0x274	; 0x274 <GPIO_PIN_WRITE_LOGIC>
 78e:	8a 83       	std	Y+2, r24	; 0x02
	}
	return Retval;
 790:	8a 81       	ldd	r24, Y+2	; 0x02
}
 792:	0f 90       	pop	r0
 794:	0f 90       	pop	r0
 796:	0f 90       	pop	r0
 798:	0f 90       	pop	r0
 79a:	cf 91       	pop	r28
 79c:	df 91       	pop	r29
 79e:	08 95       	ret

000007a0 <RELAY_TOGGLE>:
Std_ReturnType RELAY_TOGGLE (const RELAY_T *relay){
 7a0:	df 93       	push	r29
 7a2:	cf 93       	push	r28
 7a4:	00 d0       	rcall	.+0      	; 0x7a6 <RELAY_TOGGLE+0x6>
 7a6:	0f 92       	push	r0
 7a8:	cd b7       	in	r28, 0x3d	; 61
 7aa:	de b7       	in	r29, 0x3e	; 62
 7ac:	9b 83       	std	Y+3, r25	; 0x03
 7ae:	8a 83       	std	Y+2, r24	; 0x02
	Std_ReturnType Retval = E_OK;
 7b0:	81 e0       	ldi	r24, 0x01	; 1
 7b2:	89 83       	std	Y+1, r24	; 0x01
	if(NULL == relay){
 7b4:	8a 81       	ldd	r24, Y+2	; 0x02
 7b6:	9b 81       	ldd	r25, Y+3	; 0x03
 7b8:	00 97       	sbiw	r24, 0x00	; 0
 7ba:	11 f4       	brne	.+4      	; 0x7c0 <RELAY_TOGGLE+0x20>
		Retval = E_NOT_OK;
 7bc:	19 82       	std	Y+1, r1	; 0x01
 7be:	05 c0       	rjmp	.+10     	; 0x7ca <RELAY_TOGGLE+0x2a>
	}
	else{
		Retval = GPIO_PIN_TOGGLE_LOGIC(&(relay->RELAY_PIN));
 7c0:	8a 81       	ldd	r24, Y+2	; 0x02
 7c2:	9b 81       	ldd	r25, Y+3	; 0x03
 7c4:	0e 94 26 02 	call	0x44c	; 0x44c <GPIO_PIN_TOGGLE_LOGIC>
 7c8:	89 83       	std	Y+1, r24	; 0x01
	}
	return Retval;
 7ca:	89 81       	ldd	r24, Y+1	; 0x01
}
 7cc:	0f 90       	pop	r0
 7ce:	0f 90       	pop	r0
 7d0:	0f 90       	pop	r0
 7d2:	cf 91       	pop	r28
 7d4:	df 91       	pop	r29
 7d6:	08 95       	ret

000007d8 <RELAY_GET_STATUS>:
Std_ReturnType RELAY_GET_STATUS (const RELAY_T *relay , LOGIC_T *relay_st){
 7d8:	df 93       	push	r29
 7da:	cf 93       	push	r28
 7dc:	00 d0       	rcall	.+0      	; 0x7de <RELAY_GET_STATUS+0x6>
 7de:	00 d0       	rcall	.+0      	; 0x7e0 <RELAY_GET_STATUS+0x8>
 7e0:	0f 92       	push	r0
 7e2:	cd b7       	in	r28, 0x3d	; 61
 7e4:	de b7       	in	r29, 0x3e	; 62
 7e6:	9b 83       	std	Y+3, r25	; 0x03
 7e8:	8a 83       	std	Y+2, r24	; 0x02
 7ea:	7d 83       	std	Y+5, r23	; 0x05
 7ec:	6c 83       	std	Y+4, r22	; 0x04
	Std_ReturnType Retval = E_OK;
 7ee:	81 e0       	ldi	r24, 0x01	; 1
 7f0:	89 83       	std	Y+1, r24	; 0x01
	if(NULL == relay || NULL == relay_st){
 7f2:	8a 81       	ldd	r24, Y+2	; 0x02
 7f4:	9b 81       	ldd	r25, Y+3	; 0x03
 7f6:	00 97       	sbiw	r24, 0x00	; 0
 7f8:	21 f0       	breq	.+8      	; 0x802 <RELAY_GET_STATUS+0x2a>
 7fa:	8c 81       	ldd	r24, Y+4	; 0x04
 7fc:	9d 81       	ldd	r25, Y+5	; 0x05
 7fe:	00 97       	sbiw	r24, 0x00	; 0
 800:	11 f4       	brne	.+4      	; 0x806 <RELAY_GET_STATUS+0x2e>
		Retval = E_NOT_OK;
 802:	19 82       	std	Y+1, r1	; 0x01
 804:	08 c0       	rjmp	.+16     	; 0x816 <RELAY_GET_STATUS+0x3e>
	}
	else{
		Retval = GPIO_PIN_READ_LOGIC(&(relay->RELAY_PIN) , relay_st);
 806:	8a 81       	ldd	r24, Y+2	; 0x02
 808:	9b 81       	ldd	r25, Y+3	; 0x03
 80a:	2c 81       	ldd	r18, Y+4	; 0x04
 80c:	3d 81       	ldd	r19, Y+5	; 0x05
 80e:	b9 01       	movw	r22, r18
 810:	0e 94 d5 01 	call	0x3aa	; 0x3aa <GPIO_PIN_READ_LOGIC>
 814:	89 83       	std	Y+1, r24	; 0x01
	}
	return Retval;
 816:	89 81       	ldd	r24, Y+1	; 0x01
}
 818:	0f 90       	pop	r0
 81a:	0f 90       	pop	r0
 81c:	0f 90       	pop	r0
 81e:	0f 90       	pop	r0
 820:	0f 90       	pop	r0
 822:	cf 91       	pop	r28
 824:	df 91       	pop	r29
 826:	08 95       	ret

00000828 <LED_INITIALIZE>:


#include "ECU_LED.h"


Std_ReturnType LED_INITIALIZE(const LED_T *led){
 828:	df 93       	push	r29
 82a:	cf 93       	push	r28
 82c:	00 d0       	rcall	.+0      	; 0x82e <LED_INITIALIZE+0x6>
 82e:	0f 92       	push	r0
 830:	cd b7       	in	r28, 0x3d	; 61
 832:	de b7       	in	r29, 0x3e	; 62
 834:	9b 83       	std	Y+3, r25	; 0x03
 836:	8a 83       	std	Y+2, r24	; 0x02
	Std_ReturnType Retval = E_OK;
 838:	81 e0       	ldi	r24, 0x01	; 1
 83a:	89 83       	std	Y+1, r24	; 0x01
	if(NULL == led){
 83c:	8a 81       	ldd	r24, Y+2	; 0x02
 83e:	9b 81       	ldd	r25, Y+3	; 0x03
 840:	00 97       	sbiw	r24, 0x00	; 0
 842:	11 f4       	brne	.+4      	; 0x848 <LED_INITIALIZE+0x20>
		Retval = E_NOT_OK;
 844:	19 82       	std	Y+1, r1	; 0x01
 846:	05 c0       	rjmp	.+10     	; 0x852 <LED_INITIALIZE+0x2a>
	}
	else{
		Retval = GPIO_PIN_INITIALIZE(&(led->LED_Pin));
 848:	8a 81       	ldd	r24, Y+2	; 0x02
 84a:	9b 81       	ldd	r25, Y+3	; 0x03
 84c:	0e 94 79 02 	call	0x4f2	; 0x4f2 <GPIO_PIN_INITIALIZE>
 850:	89 83       	std	Y+1, r24	; 0x01
	}
	return Retval;
 852:	89 81       	ldd	r24, Y+1	; 0x01
}
 854:	0f 90       	pop	r0
 856:	0f 90       	pop	r0
 858:	0f 90       	pop	r0
 85a:	cf 91       	pop	r28
 85c:	df 91       	pop	r29
 85e:	08 95       	ret

00000860 <LED_TURN_ON>:
Std_ReturnType LED_TURN_ON(const LED_T *led){
 860:	df 93       	push	r29
 862:	cf 93       	push	r28
 864:	00 d0       	rcall	.+0      	; 0x866 <LED_TURN_ON+0x6>
 866:	0f 92       	push	r0
 868:	cd b7       	in	r28, 0x3d	; 61
 86a:	de b7       	in	r29, 0x3e	; 62
 86c:	9b 83       	std	Y+3, r25	; 0x03
 86e:	8a 83       	std	Y+2, r24	; 0x02
	Std_ReturnType Retval = E_OK;
 870:	81 e0       	ldi	r24, 0x01	; 1
 872:	89 83       	std	Y+1, r24	; 0x01
	if(NULL == led){
 874:	8a 81       	ldd	r24, Y+2	; 0x02
 876:	9b 81       	ldd	r25, Y+3	; 0x03
 878:	00 97       	sbiw	r24, 0x00	; 0
 87a:	11 f4       	brne	.+4      	; 0x880 <LED_TURN_ON+0x20>
		Retval = E_NOT_OK;
 87c:	19 82       	std	Y+1, r1	; 0x01
 87e:	06 c0       	rjmp	.+12     	; 0x88c <LED_TURN_ON+0x2c>
	}
	else{
		Retval = GPIO_PIN_WRITE_LOGIC(&(led->LED_Pin),(LOGIC_T)LED_ON);
 880:	8a 81       	ldd	r24, Y+2	; 0x02
 882:	9b 81       	ldd	r25, Y+3	; 0x03
 884:	61 e0       	ldi	r22, 0x01	; 1
 886:	0e 94 3a 01 	call	0x274	; 0x274 <GPIO_PIN_WRITE_LOGIC>
 88a:	89 83       	std	Y+1, r24	; 0x01
	}
	return Retval;
 88c:	89 81       	ldd	r24, Y+1	; 0x01
}
 88e:	0f 90       	pop	r0
 890:	0f 90       	pop	r0
 892:	0f 90       	pop	r0
 894:	cf 91       	pop	r28
 896:	df 91       	pop	r29
 898:	08 95       	ret

0000089a <LED_TURN_OFF>:
Std_ReturnType LED_TURN_OFF(const LED_T *led){
 89a:	df 93       	push	r29
 89c:	cf 93       	push	r28
 89e:	00 d0       	rcall	.+0      	; 0x8a0 <LED_TURN_OFF+0x6>
 8a0:	0f 92       	push	r0
 8a2:	cd b7       	in	r28, 0x3d	; 61
 8a4:	de b7       	in	r29, 0x3e	; 62
 8a6:	9b 83       	std	Y+3, r25	; 0x03
 8a8:	8a 83       	std	Y+2, r24	; 0x02
	Std_ReturnType Retval = E_OK;
 8aa:	81 e0       	ldi	r24, 0x01	; 1
 8ac:	89 83       	std	Y+1, r24	; 0x01
	if(NULL == led){
 8ae:	8a 81       	ldd	r24, Y+2	; 0x02
 8b0:	9b 81       	ldd	r25, Y+3	; 0x03
 8b2:	00 97       	sbiw	r24, 0x00	; 0
 8b4:	11 f4       	brne	.+4      	; 0x8ba <LED_TURN_OFF+0x20>
		Retval = E_NOT_OK;
 8b6:	19 82       	std	Y+1, r1	; 0x01
 8b8:	06 c0       	rjmp	.+12     	; 0x8c6 <LED_TURN_OFF+0x2c>
	}
	else{
		Retval = GPIO_PIN_WRITE_LOGIC(&(led->LED_Pin),(LOGIC_T)LED_OFF);
 8ba:	8a 81       	ldd	r24, Y+2	; 0x02
 8bc:	9b 81       	ldd	r25, Y+3	; 0x03
 8be:	60 e0       	ldi	r22, 0x00	; 0
 8c0:	0e 94 3a 01 	call	0x274	; 0x274 <GPIO_PIN_WRITE_LOGIC>
 8c4:	89 83       	std	Y+1, r24	; 0x01
	}
	return Retval;
 8c6:	89 81       	ldd	r24, Y+1	; 0x01
}
 8c8:	0f 90       	pop	r0
 8ca:	0f 90       	pop	r0
 8cc:	0f 90       	pop	r0
 8ce:	cf 91       	pop	r28
 8d0:	df 91       	pop	r29
 8d2:	08 95       	ret

000008d4 <LED_TOGGLE>:
Std_ReturnType LED_TOGGLE(const LED_T *led){
 8d4:	df 93       	push	r29
 8d6:	cf 93       	push	r28
 8d8:	00 d0       	rcall	.+0      	; 0x8da <LED_TOGGLE+0x6>
 8da:	0f 92       	push	r0
 8dc:	cd b7       	in	r28, 0x3d	; 61
 8de:	de b7       	in	r29, 0x3e	; 62
 8e0:	9b 83       	std	Y+3, r25	; 0x03
 8e2:	8a 83       	std	Y+2, r24	; 0x02
	Std_ReturnType Retval = E_OK;
 8e4:	81 e0       	ldi	r24, 0x01	; 1
 8e6:	89 83       	std	Y+1, r24	; 0x01
	if(NULL == led){
 8e8:	8a 81       	ldd	r24, Y+2	; 0x02
 8ea:	9b 81       	ldd	r25, Y+3	; 0x03
 8ec:	00 97       	sbiw	r24, 0x00	; 0
 8ee:	11 f4       	brne	.+4      	; 0x8f4 <LED_TOGGLE+0x20>
		Retval = E_NOT_OK;
 8f0:	19 82       	std	Y+1, r1	; 0x01
 8f2:	05 c0       	rjmp	.+10     	; 0x8fe <LED_TOGGLE+0x2a>
	}
	else{
		Retval = GPIO_PIN_TOGGLE_LOGIC(&(led->LED_Pin));
 8f4:	8a 81       	ldd	r24, Y+2	; 0x02
 8f6:	9b 81       	ldd	r25, Y+3	; 0x03
 8f8:	0e 94 26 02 	call	0x44c	; 0x44c <GPIO_PIN_TOGGLE_LOGIC>
 8fc:	89 83       	std	Y+1, r24	; 0x01
	}
	return Retval;
 8fe:	89 81       	ldd	r24, Y+1	; 0x01
}
 900:	0f 90       	pop	r0
 902:	0f 90       	pop	r0
 904:	0f 90       	pop	r0
 906:	cf 91       	pop	r28
 908:	df 91       	pop	r29
 90a:	08 95       	ret

0000090c <LED_GET_LOGIC>:
Std_ReturnType LED_GET_LOGIC(const LED_T *led,LOGIC_T *LOG){
 90c:	df 93       	push	r29
 90e:	cf 93       	push	r28
 910:	00 d0       	rcall	.+0      	; 0x912 <LED_GET_LOGIC+0x6>
 912:	00 d0       	rcall	.+0      	; 0x914 <LED_GET_LOGIC+0x8>
 914:	0f 92       	push	r0
 916:	cd b7       	in	r28, 0x3d	; 61
 918:	de b7       	in	r29, 0x3e	; 62
 91a:	9b 83       	std	Y+3, r25	; 0x03
 91c:	8a 83       	std	Y+2, r24	; 0x02
 91e:	7d 83       	std	Y+5, r23	; 0x05
 920:	6c 83       	std	Y+4, r22	; 0x04
	Std_ReturnType Retval = E_OK;
 922:	81 e0       	ldi	r24, 0x01	; 1
 924:	89 83       	std	Y+1, r24	; 0x01
	if(NULL == led || NULL == LOG){
 926:	8a 81       	ldd	r24, Y+2	; 0x02
 928:	9b 81       	ldd	r25, Y+3	; 0x03
 92a:	00 97       	sbiw	r24, 0x00	; 0
 92c:	21 f0       	breq	.+8      	; 0x936 <LED_GET_LOGIC+0x2a>
 92e:	8c 81       	ldd	r24, Y+4	; 0x04
 930:	9d 81       	ldd	r25, Y+5	; 0x05
 932:	00 97       	sbiw	r24, 0x00	; 0
 934:	11 f4       	brne	.+4      	; 0x93a <LED_GET_LOGIC+0x2e>
		Retval = E_NOT_OK;
 936:	19 82       	std	Y+1, r1	; 0x01
 938:	08 c0       	rjmp	.+16     	; 0x94a <LED_GET_LOGIC+0x3e>
	}
	else{
		Retval = GPIO_PIN_READ_LOGIC(&(led->LED_Pin),LOG);
 93a:	8a 81       	ldd	r24, Y+2	; 0x02
 93c:	9b 81       	ldd	r25, Y+3	; 0x03
 93e:	2c 81       	ldd	r18, Y+4	; 0x04
 940:	3d 81       	ldd	r19, Y+5	; 0x05
 942:	b9 01       	movw	r22, r18
 944:	0e 94 d5 01 	call	0x3aa	; 0x3aa <GPIO_PIN_READ_LOGIC>
 948:	89 83       	std	Y+1, r24	; 0x01
	}
	return Retval;
 94a:	89 81       	ldd	r24, Y+1	; 0x01
}
 94c:	0f 90       	pop	r0
 94e:	0f 90       	pop	r0
 950:	0f 90       	pop	r0
 952:	0f 90       	pop	r0
 954:	0f 90       	pop	r0
 956:	cf 91       	pop	r28
 958:	df 91       	pop	r29
 95a:	08 95       	ret

0000095c <KEYPAD_INITIALIZE>:
													   {'1' , '2' , '3' , '-'} ,
													   {'C' , '0' , '=' , '+'}};

#if KEYPAD_CFG_ENABLE == KEYPAD_CFG

Std_ReturnType KEYPAD_INITIALIZE(const KEYPAD_T *keypad){
 95c:	df 93       	push	r29
 95e:	cf 93       	push	r28
 960:	00 d0       	rcall	.+0      	; 0x962 <KEYPAD_INITIALIZE+0x6>
 962:	00 d0       	rcall	.+0      	; 0x964 <KEYPAD_INITIALIZE+0x8>
 964:	0f 92       	push	r0
 966:	cd b7       	in	r28, 0x3d	; 61
 968:	de b7       	in	r29, 0x3e	; 62
 96a:	9d 83       	std	Y+5, r25	; 0x05
 96c:	8c 83       	std	Y+4, r24	; 0x04
	Std_ReturnType Retval = E_OK;
 96e:	81 e0       	ldi	r24, 0x01	; 1
 970:	8b 83       	std	Y+3, r24	; 0x03
	if(NULL == keypad){
 972:	8c 81       	ldd	r24, Y+4	; 0x04
 974:	9d 81       	ldd	r25, Y+5	; 0x05
 976:	00 97       	sbiw	r24, 0x00	; 0
 978:	11 f4       	brne	.+4      	; 0x97e <KEYPAD_INITIALIZE+0x22>
		Retval = E_NOT_OK;
 97a:	1b 82       	std	Y+3, r1	; 0x03
 97c:	27 c0       	rjmp	.+78     	; 0x9cc <KEYPAD_INITIALIZE+0x70>
	}
	else{
		for(uint8 r = 0 ; r < (KEYPAD_ROWS) ; r++){
 97e:	1a 82       	std	Y+2, r1	; 0x02
 980:	0d c0       	rjmp	.+26     	; 0x99c <KEYPAD_INITIALIZE+0x40>
			Retval = GPIO_PIN_INITIALIZE(&(keypad->KEYPAD_ROWS_PINS[r]));
 982:	2c 81       	ldd	r18, Y+4	; 0x04
 984:	3d 81       	ldd	r19, Y+5	; 0x05
 986:	8a 81       	ldd	r24, Y+2	; 0x02
 988:	88 2f       	mov	r24, r24
 98a:	90 e0       	ldi	r25, 0x00	; 0
 98c:	82 0f       	add	r24, r18
 98e:	93 1f       	adc	r25, r19
 990:	0e 94 79 02 	call	0x4f2	; 0x4f2 <GPIO_PIN_INITIALIZE>
 994:	8b 83       	std	Y+3, r24	; 0x03
	Std_ReturnType Retval = E_OK;
	if(NULL == keypad){
		Retval = E_NOT_OK;
	}
	else{
		for(uint8 r = 0 ; r < (KEYPAD_ROWS) ; r++){
 996:	8a 81       	ldd	r24, Y+2	; 0x02
 998:	8f 5f       	subi	r24, 0xFF	; 255
 99a:	8a 83       	std	Y+2, r24	; 0x02
 99c:	8a 81       	ldd	r24, Y+2	; 0x02
 99e:	84 30       	cpi	r24, 0x04	; 4
 9a0:	80 f3       	brcs	.-32     	; 0x982 <KEYPAD_INITIALIZE+0x26>
			Retval = GPIO_PIN_INITIALIZE(&(keypad->KEYPAD_ROWS_PINS[r]));
		}
		for(uint8 c = 0 ; c < (KEYPAD_COLUMNS) ; c++){
 9a2:	19 82       	std	Y+1, r1	; 0x01
 9a4:	10 c0       	rjmp	.+32     	; 0x9c6 <KEYPAD_INITIALIZE+0x6a>
			Retval = GPIO_PIN_DIRECTION_INITIALIZE(&(keypad->KEYPAD_COLUMNS_PINS[c]));
 9a6:	8c 81       	ldd	r24, Y+4	; 0x04
 9a8:	9d 81       	ldd	r25, Y+5	; 0x05
 9aa:	9c 01       	movw	r18, r24
 9ac:	2c 5f       	subi	r18, 0xFC	; 252
 9ae:	3f 4f       	sbci	r19, 0xFF	; 255
 9b0:	89 81       	ldd	r24, Y+1	; 0x01
 9b2:	88 2f       	mov	r24, r24
 9b4:	90 e0       	ldi	r25, 0x00	; 0
 9b6:	82 0f       	add	r24, r18
 9b8:	93 1f       	adc	r25, r19
 9ba:	0e 94 49 00 	call	0x92	; 0x92 <GPIO_PIN_DIRECTION_INITIALIZE>
 9be:	8b 83       	std	Y+3, r24	; 0x03
	}
	else{
		for(uint8 r = 0 ; r < (KEYPAD_ROWS) ; r++){
			Retval = GPIO_PIN_INITIALIZE(&(keypad->KEYPAD_ROWS_PINS[r]));
		}
		for(uint8 c = 0 ; c < (KEYPAD_COLUMNS) ; c++){
 9c0:	89 81       	ldd	r24, Y+1	; 0x01
 9c2:	8f 5f       	subi	r24, 0xFF	; 255
 9c4:	89 83       	std	Y+1, r24	; 0x01
 9c6:	89 81       	ldd	r24, Y+1	; 0x01
 9c8:	84 30       	cpi	r24, 0x04	; 4
 9ca:	68 f3       	brcs	.-38     	; 0x9a6 <KEYPAD_INITIALIZE+0x4a>
			Retval = GPIO_PIN_DIRECTION_INITIALIZE(&(keypad->KEYPAD_COLUMNS_PINS[c]));
		}
	}
	return Retval;
 9cc:	8b 81       	ldd	r24, Y+3	; 0x03
}
 9ce:	0f 90       	pop	r0
 9d0:	0f 90       	pop	r0
 9d2:	0f 90       	pop	r0
 9d4:	0f 90       	pop	r0
 9d6:	0f 90       	pop	r0
 9d8:	cf 91       	pop	r28
 9da:	df 91       	pop	r29
 9dc:	08 95       	ret

000009de <KEYPAD_GET_DATA>:

#endif

#if KEYPAD_CFG_ENABLE == KEYPAD_CFG

Std_ReturnType KEYPAD_GET_DATA(const KEYPAD_T *keypad , uint8 *data){
 9de:	df 93       	push	r29
 9e0:	cf 93       	push	r28
 9e2:	cd b7       	in	r28, 0x3d	; 61
 9e4:	de b7       	in	r29, 0x3e	; 62
 9e6:	29 97       	sbiw	r28, 0x09	; 9
 9e8:	0f b6       	in	r0, 0x3f	; 63
 9ea:	f8 94       	cli
 9ec:	de bf       	out	0x3e, r29	; 62
 9ee:	0f be       	out	0x3f, r0	; 63
 9f0:	cd bf       	out	0x3d, r28	; 61
 9f2:	9f 83       	std	Y+7, r25	; 0x07
 9f4:	8e 83       	std	Y+6, r24	; 0x06
 9f6:	79 87       	std	Y+9, r23	; 0x09
 9f8:	68 87       	std	Y+8, r22	; 0x08
	Std_ReturnType Retval = E_OK;
 9fa:	81 e0       	ldi	r24, 0x01	; 1
 9fc:	8c 83       	std	Y+4, r24	; 0x04
	if(NULL == keypad || NULL == data){
 9fe:	8e 81       	ldd	r24, Y+6	; 0x06
 a00:	9f 81       	ldd	r25, Y+7	; 0x07
 a02:	00 97       	sbiw	r24, 0x00	; 0
 a04:	21 f0       	breq	.+8      	; 0xa0e <KEYPAD_GET_DATA+0x30>
 a06:	88 85       	ldd	r24, Y+8	; 0x08
 a08:	99 85       	ldd	r25, Y+9	; 0x09
 a0a:	00 97       	sbiw	r24, 0x00	; 0
 a0c:	11 f4       	brne	.+4      	; 0xa12 <KEYPAD_GET_DATA+0x34>
		Retval = E_NOT_OK;
 a0e:	1c 82       	std	Y+4, r1	; 0x04
 a10:	7b c0       	rjmp	.+246    	; 0xb08 <KEYPAD_GET_DATA+0x12a>
	}
	else{
		LOGIC_T log = GPIO_LOW;
 a12:	1d 82       	std	Y+5, r1	; 0x05
		for(uint8 r = 0 ; r < (KEYPAD_ROWS) ; r++){
 a14:	1b 82       	std	Y+3, r1	; 0x03
 a16:	74 c0       	rjmp	.+232    	; 0xb00 <KEYPAD_GET_DATA+0x122>
			for(uint8 i = 0 ; i < (KEYPAD_ROWS) ; i++){
 a18:	1a 82       	std	Y+2, r1	; 0x02
 a1a:	0e c0       	rjmp	.+28     	; 0xa38 <KEYPAD_GET_DATA+0x5a>
				Retval = GPIO_PIN_WRITE_LOGIC(&(keypad->KEYPAD_ROWS_PINS[i]) , GPIO_LOW);
 a1c:	2e 81       	ldd	r18, Y+6	; 0x06
 a1e:	3f 81       	ldd	r19, Y+7	; 0x07
 a20:	8a 81       	ldd	r24, Y+2	; 0x02
 a22:	88 2f       	mov	r24, r24
 a24:	90 e0       	ldi	r25, 0x00	; 0
 a26:	82 0f       	add	r24, r18
 a28:	93 1f       	adc	r25, r19
 a2a:	60 e0       	ldi	r22, 0x00	; 0
 a2c:	0e 94 3a 01 	call	0x274	; 0x274 <GPIO_PIN_WRITE_LOGIC>
 a30:	8c 83       	std	Y+4, r24	; 0x04
		Retval = E_NOT_OK;
	}
	else{
		LOGIC_T log = GPIO_LOW;
		for(uint8 r = 0 ; r < (KEYPAD_ROWS) ; r++){
			for(uint8 i = 0 ; i < (KEYPAD_ROWS) ; i++){
 a32:	8a 81       	ldd	r24, Y+2	; 0x02
 a34:	8f 5f       	subi	r24, 0xFF	; 255
 a36:	8a 83       	std	Y+2, r24	; 0x02
 a38:	8a 81       	ldd	r24, Y+2	; 0x02
 a3a:	84 30       	cpi	r24, 0x04	; 4
 a3c:	78 f3       	brcs	.-34     	; 0xa1c <KEYPAD_GET_DATA+0x3e>
				Retval = GPIO_PIN_WRITE_LOGIC(&(keypad->KEYPAD_ROWS_PINS[i]) , GPIO_LOW);
			}
			Retval = GPIO_PIN_WRITE_LOGIC(&(keypad->KEYPAD_ROWS_PINS[r]) , GPIO_HIGH);
 a3e:	2e 81       	ldd	r18, Y+6	; 0x06
 a40:	3f 81       	ldd	r19, Y+7	; 0x07
 a42:	8b 81       	ldd	r24, Y+3	; 0x03
 a44:	88 2f       	mov	r24, r24
 a46:	90 e0       	ldi	r25, 0x00	; 0
 a48:	82 0f       	add	r24, r18
 a4a:	93 1f       	adc	r25, r19
 a4c:	61 e0       	ldi	r22, 0x01	; 1
 a4e:	0e 94 3a 01 	call	0x274	; 0x274 <GPIO_PIN_WRITE_LOGIC>
 a52:	8c 83       	std	Y+4, r24	; 0x04
			for(uint8 c = 0 ; c < (KEYPAD_COLUMNS) ; c++){
 a54:	19 82       	std	Y+1, r1	; 0x01
 a56:	4d c0       	rjmp	.+154    	; 0xaf2 <KEYPAD_GET_DATA+0x114>
				Retval = GPIO_PIN_READ_LOGIC(&(keypad->KEYPAD_COLUMNS_PINS[c]) , &log);
 a58:	8e 81       	ldd	r24, Y+6	; 0x06
 a5a:	9f 81       	ldd	r25, Y+7	; 0x07
 a5c:	9c 01       	movw	r18, r24
 a5e:	2c 5f       	subi	r18, 0xFC	; 252
 a60:	3f 4f       	sbci	r19, 0xFF	; 255
 a62:	89 81       	ldd	r24, Y+1	; 0x01
 a64:	88 2f       	mov	r24, r24
 a66:	90 e0       	ldi	r25, 0x00	; 0
 a68:	82 0f       	add	r24, r18
 a6a:	93 1f       	adc	r25, r19
 a6c:	9e 01       	movw	r18, r28
 a6e:	2b 5f       	subi	r18, 0xFB	; 251
 a70:	3f 4f       	sbci	r19, 0xFF	; 255
 a72:	b9 01       	movw	r22, r18
 a74:	0e 94 d5 01 	call	0x3aa	; 0x3aa <GPIO_PIN_READ_LOGIC>
 a78:	8c 83       	std	Y+4, r24	; 0x04
				if(KEYPAD_ACTIVE_HIGH == keypad->KEYPAD_CON){
 a7a:	ee 81       	ldd	r30, Y+6	; 0x06
 a7c:	ff 81       	ldd	r31, Y+7	; 0x07
 a7e:	80 85       	ldd	r24, Z+8	; 0x08
 a80:	88 23       	and	r24, r24
 a82:	c1 f4       	brne	.+48     	; 0xab4 <KEYPAD_GET_DATA+0xd6>
					if(GPIO_HIGH == log){
 a84:	8d 81       	ldd	r24, Y+5	; 0x05
 a86:	81 30       	cpi	r24, 0x01	; 1
 a88:	89 f5       	brne	.+98     	; 0xaec <KEYPAD_GET_DATA+0x10e>
						*data = keypad_semi_calc[r][c];
 a8a:	8b 81       	ldd	r24, Y+3	; 0x03
 a8c:	48 2f       	mov	r20, r24
 a8e:	50 e0       	ldi	r21, 0x00	; 0
 a90:	89 81       	ldd	r24, Y+1	; 0x01
 a92:	28 2f       	mov	r18, r24
 a94:	30 e0       	ldi	r19, 0x00	; 0
 a96:	ca 01       	movw	r24, r20
 a98:	88 0f       	add	r24, r24
 a9a:	99 1f       	adc	r25, r25
 a9c:	88 0f       	add	r24, r24
 a9e:	99 1f       	adc	r25, r25
 aa0:	82 0f       	add	r24, r18
 aa2:	93 1f       	adc	r25, r19
 aa4:	fc 01       	movw	r30, r24
 aa6:	e8 58       	subi	r30, 0x88	; 136
 aa8:	ff 4f       	sbci	r31, 0xFF	; 255
 aaa:	80 81       	ld	r24, Z
 aac:	e8 85       	ldd	r30, Y+8	; 0x08
 aae:	f9 85       	ldd	r31, Y+9	; 0x09
 ab0:	80 83       	st	Z, r24
 ab2:	1c c0       	rjmp	.+56     	; 0xaec <KEYPAD_GET_DATA+0x10e>
					}
					else{}
				}
				else if(KEYPAD_ACTIVE_LOW == keypad->KEYPAD_CON){
 ab4:	ee 81       	ldd	r30, Y+6	; 0x06
 ab6:	ff 81       	ldd	r31, Y+7	; 0x07
 ab8:	80 85       	ldd	r24, Z+8	; 0x08
 aba:	81 30       	cpi	r24, 0x01	; 1
 abc:	b9 f4       	brne	.+46     	; 0xaec <KEYPAD_GET_DATA+0x10e>
					if(GPIO_LOW == log){
 abe:	8d 81       	ldd	r24, Y+5	; 0x05
 ac0:	88 23       	and	r24, r24
 ac2:	a1 f4       	brne	.+40     	; 0xaec <KEYPAD_GET_DATA+0x10e>
						*data = keypad_semi_calc[r][c];
 ac4:	8b 81       	ldd	r24, Y+3	; 0x03
 ac6:	48 2f       	mov	r20, r24
 ac8:	50 e0       	ldi	r21, 0x00	; 0
 aca:	89 81       	ldd	r24, Y+1	; 0x01
 acc:	28 2f       	mov	r18, r24
 ace:	30 e0       	ldi	r19, 0x00	; 0
 ad0:	ca 01       	movw	r24, r20
 ad2:	88 0f       	add	r24, r24
 ad4:	99 1f       	adc	r25, r25
 ad6:	88 0f       	add	r24, r24
 ad8:	99 1f       	adc	r25, r25
 ada:	82 0f       	add	r24, r18
 adc:	93 1f       	adc	r25, r19
 ade:	fc 01       	movw	r30, r24
 ae0:	e8 58       	subi	r30, 0x88	; 136
 ae2:	ff 4f       	sbci	r31, 0xFF	; 255
 ae4:	80 81       	ld	r24, Z
 ae6:	e8 85       	ldd	r30, Y+8	; 0x08
 ae8:	f9 85       	ldd	r31, Y+9	; 0x09
 aea:	80 83       	st	Z, r24
		for(uint8 r = 0 ; r < (KEYPAD_ROWS) ; r++){
			for(uint8 i = 0 ; i < (KEYPAD_ROWS) ; i++){
				Retval = GPIO_PIN_WRITE_LOGIC(&(keypad->KEYPAD_ROWS_PINS[i]) , GPIO_LOW);
			}
			Retval = GPIO_PIN_WRITE_LOGIC(&(keypad->KEYPAD_ROWS_PINS[r]) , GPIO_HIGH);
			for(uint8 c = 0 ; c < (KEYPAD_COLUMNS) ; c++){
 aec:	89 81       	ldd	r24, Y+1	; 0x01
 aee:	8f 5f       	subi	r24, 0xFF	; 255
 af0:	89 83       	std	Y+1, r24	; 0x01
 af2:	89 81       	ldd	r24, Y+1	; 0x01
 af4:	84 30       	cpi	r24, 0x04	; 4
 af6:	08 f4       	brcc	.+2      	; 0xafa <KEYPAD_GET_DATA+0x11c>
 af8:	af cf       	rjmp	.-162    	; 0xa58 <KEYPAD_GET_DATA+0x7a>
	if(NULL == keypad || NULL == data){
		Retval = E_NOT_OK;
	}
	else{
		LOGIC_T log = GPIO_LOW;
		for(uint8 r = 0 ; r < (KEYPAD_ROWS) ; r++){
 afa:	8b 81       	ldd	r24, Y+3	; 0x03
 afc:	8f 5f       	subi	r24, 0xFF	; 255
 afe:	8b 83       	std	Y+3, r24	; 0x03
 b00:	8b 81       	ldd	r24, Y+3	; 0x03
 b02:	84 30       	cpi	r24, 0x04	; 4
 b04:	08 f4       	brcc	.+2      	; 0xb08 <KEYPAD_GET_DATA+0x12a>
 b06:	88 cf       	rjmp	.-240    	; 0xa18 <KEYPAD_GET_DATA+0x3a>
				}
				else{}
			}
		}
	}
	return Retval;
 b08:	8c 81       	ldd	r24, Y+4	; 0x04
}
 b0a:	29 96       	adiw	r28, 0x09	; 9
 b0c:	0f b6       	in	r0, 0x3f	; 63
 b0e:	f8 94       	cli
 b10:	de bf       	out	0x3e, r29	; 62
 b12:	0f be       	out	0x3f, r0	; 63
 b14:	cd bf       	out	0x3d, r28	; 61
 b16:	cf 91       	pop	r28
 b18:	df 91       	pop	r29
 b1a:	08 95       	ret

00000b1c <DC_MOTOR_INITIALIZE>:

#include "ECU_DC_MOTOR.h"

#if DC_MOTOR_CFG == (DC_MOTOR_CFG_ENABLE)

Std_ReturnType DC_MOTOR_INITIALIZE(const DC_MOTOR_T *motor){
 b1c:	df 93       	push	r29
 b1e:	cf 93       	push	r28
 b20:	00 d0       	rcall	.+0      	; 0xb22 <DC_MOTOR_INITIALIZE+0x6>
 b22:	0f 92       	push	r0
 b24:	cd b7       	in	r28, 0x3d	; 61
 b26:	de b7       	in	r29, 0x3e	; 62
 b28:	9b 83       	std	Y+3, r25	; 0x03
 b2a:	8a 83       	std	Y+2, r24	; 0x02
	Std_ReturnType Retval = E_OK;
 b2c:	81 e0       	ldi	r24, 0x01	; 1
 b2e:	89 83       	std	Y+1, r24	; 0x01
	if(NULL == motor){
 b30:	8a 81       	ldd	r24, Y+2	; 0x02
 b32:	9b 81       	ldd	r25, Y+3	; 0x03
 b34:	00 97       	sbiw	r24, 0x00	; 0
 b36:	11 f4       	brne	.+4      	; 0xb3c <DC_MOTOR_INITIALIZE+0x20>
		Retval = E_NOT_OK;
 b38:	19 82       	std	Y+1, r1	; 0x01
 b3a:	0b c0       	rjmp	.+22     	; 0xb52 <DC_MOTOR_INITIALIZE+0x36>
	}
	else{
		Retval = GPIO_PIN_INITIALIZE(&(motor->DC_MOTOR_PIN[0]));
 b3c:	8a 81       	ldd	r24, Y+2	; 0x02
 b3e:	9b 81       	ldd	r25, Y+3	; 0x03
 b40:	0e 94 79 02 	call	0x4f2	; 0x4f2 <GPIO_PIN_INITIALIZE>
 b44:	89 83       	std	Y+1, r24	; 0x01
		Retval = GPIO_PIN_INITIALIZE(&(motor->DC_MOTOR_PIN[1]));
 b46:	8a 81       	ldd	r24, Y+2	; 0x02
 b48:	9b 81       	ldd	r25, Y+3	; 0x03
 b4a:	01 96       	adiw	r24, 0x01	; 1
 b4c:	0e 94 79 02 	call	0x4f2	; 0x4f2 <GPIO_PIN_INITIALIZE>
 b50:	89 83       	std	Y+1, r24	; 0x01
	}
	return Retval;
 b52:	89 81       	ldd	r24, Y+1	; 0x01
}
 b54:	0f 90       	pop	r0
 b56:	0f 90       	pop	r0
 b58:	0f 90       	pop	r0
 b5a:	cf 91       	pop	r28
 b5c:	df 91       	pop	r29
 b5e:	08 95       	ret

00000b60 <DC_MOTOR_ROTATE_CW>:

#endif

#if DC_MOTOR_CFG == (DC_MOTOR_CFG_ENABLE)

Std_ReturnType DC_MOTOR_ROTATE_CW(const DC_MOTOR_T *motor){
 b60:	df 93       	push	r29
 b62:	cf 93       	push	r28
 b64:	00 d0       	rcall	.+0      	; 0xb66 <DC_MOTOR_ROTATE_CW+0x6>
 b66:	00 d0       	rcall	.+0      	; 0xb68 <DC_MOTOR_ROTATE_CW+0x8>
 b68:	0f 92       	push	r0
 b6a:	cd b7       	in	r28, 0x3d	; 61
 b6c:	de b7       	in	r29, 0x3e	; 62
 b6e:	9d 83       	std	Y+5, r25	; 0x05
 b70:	8c 83       	std	Y+4, r24	; 0x04
	Std_ReturnType Retval = E_OK;
 b72:	81 e0       	ldi	r24, 0x01	; 1
 b74:	8b 83       	std	Y+3, r24	; 0x03
	if(NULL == motor){
 b76:	8c 81       	ldd	r24, Y+4	; 0x04
 b78:	9d 81       	ldd	r25, Y+5	; 0x05
 b7a:	00 97       	sbiw	r24, 0x00	; 0
 b7c:	11 f4       	brne	.+4      	; 0xb82 <DC_MOTOR_ROTATE_CW+0x22>
			Retval = E_NOT_OK;
 b7e:	1b 82       	std	Y+3, r1	; 0x03
 b80:	10 c0       	rjmp	.+32     	; 0xba2 <DC_MOTOR_ROTATE_CW+0x42>
		}
		else{
			LOGIC_T IN1 = (LOGIC_T)DC_MOTOR_ON;
 b82:	81 e0       	ldi	r24, 0x01	; 1
 b84:	8a 83       	std	Y+2, r24	; 0x02
			LOGIC_T IN2 = (LOGIC_T)DC_MOTOR_OFF;
 b86:	19 82       	std	Y+1, r1	; 0x01
			Retval = GPIO_PIN_WRITE_LOGIC(&(motor->DC_MOTOR_PIN[0]) , IN1);
 b88:	8c 81       	ldd	r24, Y+4	; 0x04
 b8a:	9d 81       	ldd	r25, Y+5	; 0x05
 b8c:	6a 81       	ldd	r22, Y+2	; 0x02
 b8e:	0e 94 3a 01 	call	0x274	; 0x274 <GPIO_PIN_WRITE_LOGIC>
 b92:	8b 83       	std	Y+3, r24	; 0x03
			Retval = GPIO_PIN_WRITE_LOGIC(&(motor->DC_MOTOR_PIN[1]) , IN2);
 b94:	8c 81       	ldd	r24, Y+4	; 0x04
 b96:	9d 81       	ldd	r25, Y+5	; 0x05
 b98:	01 96       	adiw	r24, 0x01	; 1
 b9a:	69 81       	ldd	r22, Y+1	; 0x01
 b9c:	0e 94 3a 01 	call	0x274	; 0x274 <GPIO_PIN_WRITE_LOGIC>
 ba0:	8b 83       	std	Y+3, r24	; 0x03
		}
		return Retval;
 ba2:	8b 81       	ldd	r24, Y+3	; 0x03
}
 ba4:	0f 90       	pop	r0
 ba6:	0f 90       	pop	r0
 ba8:	0f 90       	pop	r0
 baa:	0f 90       	pop	r0
 bac:	0f 90       	pop	r0
 bae:	cf 91       	pop	r28
 bb0:	df 91       	pop	r29
 bb2:	08 95       	ret

00000bb4 <DC_MOTOR_ROTATE_CCW>:

#endif

#if DC_MOTOR_CFG == (DC_MOTOR_CFG_ENABLE)

Std_ReturnType DC_MOTOR_ROTATE_CCW(const DC_MOTOR_T *motor){
 bb4:	df 93       	push	r29
 bb6:	cf 93       	push	r28
 bb8:	00 d0       	rcall	.+0      	; 0xbba <DC_MOTOR_ROTATE_CCW+0x6>
 bba:	00 d0       	rcall	.+0      	; 0xbbc <DC_MOTOR_ROTATE_CCW+0x8>
 bbc:	0f 92       	push	r0
 bbe:	cd b7       	in	r28, 0x3d	; 61
 bc0:	de b7       	in	r29, 0x3e	; 62
 bc2:	9d 83       	std	Y+5, r25	; 0x05
 bc4:	8c 83       	std	Y+4, r24	; 0x04
	Std_ReturnType Retval = E_OK;
 bc6:	81 e0       	ldi	r24, 0x01	; 1
 bc8:	8b 83       	std	Y+3, r24	; 0x03
	if(NULL == motor){
 bca:	8c 81       	ldd	r24, Y+4	; 0x04
 bcc:	9d 81       	ldd	r25, Y+5	; 0x05
 bce:	00 97       	sbiw	r24, 0x00	; 0
 bd0:	11 f4       	brne	.+4      	; 0xbd6 <DC_MOTOR_ROTATE_CCW+0x22>
			Retval = E_NOT_OK;
 bd2:	1b 82       	std	Y+3, r1	; 0x03
 bd4:	10 c0       	rjmp	.+32     	; 0xbf6 <DC_MOTOR_ROTATE_CCW+0x42>
		}
		else{
			LOGIC_T IN1 = (LOGIC_T)DC_MOTOR_OFF;
 bd6:	1a 82       	std	Y+2, r1	; 0x02
			LOGIC_T IN2 = (LOGIC_T)DC_MOTOR_ON;
 bd8:	81 e0       	ldi	r24, 0x01	; 1
 bda:	89 83       	std	Y+1, r24	; 0x01
			Retval = GPIO_PIN_WRITE_LOGIC(&(motor->DC_MOTOR_PIN[0]) , IN1);
 bdc:	8c 81       	ldd	r24, Y+4	; 0x04
 bde:	9d 81       	ldd	r25, Y+5	; 0x05
 be0:	6a 81       	ldd	r22, Y+2	; 0x02
 be2:	0e 94 3a 01 	call	0x274	; 0x274 <GPIO_PIN_WRITE_LOGIC>
 be6:	8b 83       	std	Y+3, r24	; 0x03
			Retval = GPIO_PIN_WRITE_LOGIC(&(motor->DC_MOTOR_PIN[1]) , IN2);
 be8:	8c 81       	ldd	r24, Y+4	; 0x04
 bea:	9d 81       	ldd	r25, Y+5	; 0x05
 bec:	01 96       	adiw	r24, 0x01	; 1
 bee:	69 81       	ldd	r22, Y+1	; 0x01
 bf0:	0e 94 3a 01 	call	0x274	; 0x274 <GPIO_PIN_WRITE_LOGIC>
 bf4:	8b 83       	std	Y+3, r24	; 0x03
		}
		return Retval;
 bf6:	8b 81       	ldd	r24, Y+3	; 0x03
}
 bf8:	0f 90       	pop	r0
 bfa:	0f 90       	pop	r0
 bfc:	0f 90       	pop	r0
 bfe:	0f 90       	pop	r0
 c00:	0f 90       	pop	r0
 c02:	cf 91       	pop	r28
 c04:	df 91       	pop	r29
 c06:	08 95       	ret

00000c08 <DC_MOTOR_STOP>:

#endif

#if DC_MOTOR_CFG == (DC_MOTOR_CFG_ENABLE)

Std_ReturnType DC_MOTOR_STOP(const DC_MOTOR_T *motor){
 c08:	df 93       	push	r29
 c0a:	cf 93       	push	r28
 c0c:	00 d0       	rcall	.+0      	; 0xc0e <DC_MOTOR_STOP+0x6>
 c0e:	00 d0       	rcall	.+0      	; 0xc10 <DC_MOTOR_STOP+0x8>
 c10:	0f 92       	push	r0
 c12:	cd b7       	in	r28, 0x3d	; 61
 c14:	de b7       	in	r29, 0x3e	; 62
 c16:	9d 83       	std	Y+5, r25	; 0x05
 c18:	8c 83       	std	Y+4, r24	; 0x04
	Std_ReturnType Retval = E_OK;
 c1a:	81 e0       	ldi	r24, 0x01	; 1
 c1c:	8b 83       	std	Y+3, r24	; 0x03
	if(NULL == motor){
 c1e:	8c 81       	ldd	r24, Y+4	; 0x04
 c20:	9d 81       	ldd	r25, Y+5	; 0x05
 c22:	00 97       	sbiw	r24, 0x00	; 0
 c24:	11 f4       	brne	.+4      	; 0xc2a <DC_MOTOR_STOP+0x22>
			Retval = E_NOT_OK;
 c26:	1b 82       	std	Y+3, r1	; 0x03
 c28:	0f c0       	rjmp	.+30     	; 0xc48 <DC_MOTOR_STOP+0x40>
		}
		else{
			LOGIC_T IN1 = (LOGIC_T)DC_MOTOR_OFF;
 c2a:	1a 82       	std	Y+2, r1	; 0x02
			LOGIC_T IN2 = (LOGIC_T)DC_MOTOR_OFF;
 c2c:	19 82       	std	Y+1, r1	; 0x01
			Retval = GPIO_PIN_WRITE_LOGIC(&(motor->DC_MOTOR_PIN[0]) , IN1);
 c2e:	8c 81       	ldd	r24, Y+4	; 0x04
 c30:	9d 81       	ldd	r25, Y+5	; 0x05
 c32:	6a 81       	ldd	r22, Y+2	; 0x02
 c34:	0e 94 3a 01 	call	0x274	; 0x274 <GPIO_PIN_WRITE_LOGIC>
 c38:	8b 83       	std	Y+3, r24	; 0x03
			Retval = GPIO_PIN_WRITE_LOGIC(&(motor->DC_MOTOR_PIN[1]) , IN2);
 c3a:	8c 81       	ldd	r24, Y+4	; 0x04
 c3c:	9d 81       	ldd	r25, Y+5	; 0x05
 c3e:	01 96       	adiw	r24, 0x01	; 1
 c40:	69 81       	ldd	r22, Y+1	; 0x01
 c42:	0e 94 3a 01 	call	0x274	; 0x274 <GPIO_PIN_WRITE_LOGIC>
 c46:	8b 83       	std	Y+3, r24	; 0x03
		}
		return Retval;
 c48:	8b 81       	ldd	r24, Y+3	; 0x03
}
 c4a:	0f 90       	pop	r0
 c4c:	0f 90       	pop	r0
 c4e:	0f 90       	pop	r0
 c50:	0f 90       	pop	r0
 c52:	0f 90       	pop	r0
 c54:	cf 91       	pop	r28
 c56:	df 91       	pop	r29
 c58:	08 95       	ret

00000c5a <DC_MOTOR_GET_ROTATION_DIRECTION>:

#endif

#if DC_MOTOR_CFG == (DC_MOTOR_CFG_ENABLE)

Std_ReturnType DC_MOTOR_GET_ROTATION_DIRECTION(const DC_MOTOR_T *motor ,DC_MOTOR_ROTATE *rot){
 c5a:	df 93       	push	r29
 c5c:	cf 93       	push	r28
 c5e:	cd b7       	in	r28, 0x3d	; 61
 c60:	de b7       	in	r29, 0x3e	; 62
 c62:	27 97       	sbiw	r28, 0x07	; 7
 c64:	0f b6       	in	r0, 0x3f	; 63
 c66:	f8 94       	cli
 c68:	de bf       	out	0x3e, r29	; 62
 c6a:	0f be       	out	0x3f, r0	; 63
 c6c:	cd bf       	out	0x3d, r28	; 61
 c6e:	9d 83       	std	Y+5, r25	; 0x05
 c70:	8c 83       	std	Y+4, r24	; 0x04
 c72:	7f 83       	std	Y+7, r23	; 0x07
 c74:	6e 83       	std	Y+6, r22	; 0x06
	Std_ReturnType Retval = E_OK;
 c76:	81 e0       	ldi	r24, 0x01	; 1
 c78:	89 83       	std	Y+1, r24	; 0x01
	if(NULL == motor || NULL == rot){
 c7a:	8c 81       	ldd	r24, Y+4	; 0x04
 c7c:	9d 81       	ldd	r25, Y+5	; 0x05
 c7e:	00 97       	sbiw	r24, 0x00	; 0
 c80:	21 f0       	breq	.+8      	; 0xc8a <DC_MOTOR_GET_ROTATION_DIRECTION+0x30>
 c82:	8e 81       	ldd	r24, Y+6	; 0x06
 c84:	9f 81       	ldd	r25, Y+7	; 0x07
 c86:	00 97       	sbiw	r24, 0x00	; 0
 c88:	11 f4       	brne	.+4      	; 0xc8e <DC_MOTOR_GET_ROTATION_DIRECTION+0x34>
			Retval = E_NOT_OK;
 c8a:	19 82       	std	Y+1, r1	; 0x01
 c8c:	2e c0       	rjmp	.+92     	; 0xcea <DC_MOTOR_GET_ROTATION_DIRECTION+0x90>
		}
		else{
			LOGIC_T IN1 = (LOGIC_T)DC_MOTOR_OFF;
 c8e:	1a 82       	std	Y+2, r1	; 0x02
			LOGIC_T IN2 = (LOGIC_T)DC_MOTOR_OFF;
 c90:	1b 82       	std	Y+3, r1	; 0x03
			Retval = GPIO_PIN_READ_LOGIC(&(motor->DC_MOTOR_PIN[0]) , &(IN1));
 c92:	8c 81       	ldd	r24, Y+4	; 0x04
 c94:	9d 81       	ldd	r25, Y+5	; 0x05
 c96:	9e 01       	movw	r18, r28
 c98:	2e 5f       	subi	r18, 0xFE	; 254
 c9a:	3f 4f       	sbci	r19, 0xFF	; 255
 c9c:	b9 01       	movw	r22, r18
 c9e:	0e 94 d5 01 	call	0x3aa	; 0x3aa <GPIO_PIN_READ_LOGIC>
 ca2:	89 83       	std	Y+1, r24	; 0x01
			Retval = GPIO_PIN_READ_LOGIC(&(motor->DC_MOTOR_PIN[1]) , &(IN2));
 ca4:	8c 81       	ldd	r24, Y+4	; 0x04
 ca6:	9d 81       	ldd	r25, Y+5	; 0x05
 ca8:	01 96       	adiw	r24, 0x01	; 1
 caa:	9e 01       	movw	r18, r28
 cac:	2d 5f       	subi	r18, 0xFD	; 253
 cae:	3f 4f       	sbci	r19, 0xFF	; 255
 cb0:	b9 01       	movw	r22, r18
 cb2:	0e 94 d5 01 	call	0x3aa	; 0x3aa <GPIO_PIN_READ_LOGIC>
 cb6:	89 83       	std	Y+1, r24	; 0x01
			if(IN1 == (LOGIC_T)DC_MOTOR_ON && IN2 == (LOGIC_T)DC_MOTOR_OFF){
 cb8:	8a 81       	ldd	r24, Y+2	; 0x02
 cba:	81 30       	cpi	r24, 0x01	; 1
 cbc:	41 f4       	brne	.+16     	; 0xcce <DC_MOTOR_GET_ROTATION_DIRECTION+0x74>
 cbe:	8b 81       	ldd	r24, Y+3	; 0x03
 cc0:	88 23       	and	r24, r24
 cc2:	29 f4       	brne	.+10     	; 0xcce <DC_MOTOR_GET_ROTATION_DIRECTION+0x74>
				*rot = DC_MOTOR_CW;
 cc4:	ee 81       	ldd	r30, Y+6	; 0x06
 cc6:	ff 81       	ldd	r31, Y+7	; 0x07
 cc8:	81 e0       	ldi	r24, 0x01	; 1
 cca:	80 83       	st	Z, r24
 ccc:	0e c0       	rjmp	.+28     	; 0xcea <DC_MOTOR_GET_ROTATION_DIRECTION+0x90>
			}
			else if (IN1 == (LOGIC_T)DC_MOTOR_OFF && IN2 == (LOGIC_T)DC_MOTOR_ON){
 cce:	8a 81       	ldd	r24, Y+2	; 0x02
 cd0:	88 23       	and	r24, r24
 cd2:	41 f4       	brne	.+16     	; 0xce4 <DC_MOTOR_GET_ROTATION_DIRECTION+0x8a>
 cd4:	8b 81       	ldd	r24, Y+3	; 0x03
 cd6:	81 30       	cpi	r24, 0x01	; 1
 cd8:	29 f4       	brne	.+10     	; 0xce4 <DC_MOTOR_GET_ROTATION_DIRECTION+0x8a>
				*rot = DC_MOTOR_CCW;
 cda:	ee 81       	ldd	r30, Y+6	; 0x06
 cdc:	ff 81       	ldd	r31, Y+7	; 0x07
 cde:	82 e0       	ldi	r24, 0x02	; 2
 ce0:	80 83       	st	Z, r24
 ce2:	03 c0       	rjmp	.+6      	; 0xcea <DC_MOTOR_GET_ROTATION_DIRECTION+0x90>
			}
			else{
				*rot = DC_MOTOR_STOPED;
 ce4:	ee 81       	ldd	r30, Y+6	; 0x06
 ce6:	ff 81       	ldd	r31, Y+7	; 0x07
 ce8:	10 82       	st	Z, r1
			}

		}
		return Retval;
 cea:	89 81       	ldd	r24, Y+1	; 0x01
}
 cec:	27 96       	adiw	r28, 0x07	; 7
 cee:	0f b6       	in	r0, 0x3f	; 63
 cf0:	f8 94       	cli
 cf2:	de bf       	out	0x3e, r29	; 62
 cf4:	0f be       	out	0x3f, r0	; 63
 cf6:	cd bf       	out	0x3d, r28	; 61
 cf8:	cf 91       	pop	r28
 cfa:	df 91       	pop	r29
 cfc:	08 95       	ret

00000cfe <BTN_INITIALIZE>:
 *      Author: Mohamed Elahmady
 */

#include "ECU_BTN.h"

Std_ReturnType BTN_INITIALIZE(const BTN_T *btn){
 cfe:	df 93       	push	r29
 d00:	cf 93       	push	r28
 d02:	00 d0       	rcall	.+0      	; 0xd04 <BTN_INITIALIZE+0x6>
 d04:	0f 92       	push	r0
 d06:	cd b7       	in	r28, 0x3d	; 61
 d08:	de b7       	in	r29, 0x3e	; 62
 d0a:	9b 83       	std	Y+3, r25	; 0x03
 d0c:	8a 83       	std	Y+2, r24	; 0x02
	Std_ReturnType Retval = E_OK;
 d0e:	81 e0       	ldi	r24, 0x01	; 1
 d10:	89 83       	std	Y+1, r24	; 0x01
	if(NULL == btn){
 d12:	8a 81       	ldd	r24, Y+2	; 0x02
 d14:	9b 81       	ldd	r25, Y+3	; 0x03
 d16:	00 97       	sbiw	r24, 0x00	; 0
 d18:	11 f4       	brne	.+4      	; 0xd1e <BTN_INITIALIZE+0x20>
		Retval = E_NOT_OK;
 d1a:	19 82       	std	Y+1, r1	; 0x01
 d1c:	05 c0       	rjmp	.+10     	; 0xd28 <BTN_INITIALIZE+0x2a>
	}
	else{
		Retval = GPIO_PIN_DIRECTION_INITIALIZE(&(btn->PIN));
 d1e:	8a 81       	ldd	r24, Y+2	; 0x02
 d20:	9b 81       	ldd	r25, Y+3	; 0x03
 d22:	0e 94 49 00 	call	0x92	; 0x92 <GPIO_PIN_DIRECTION_INITIALIZE>
 d26:	89 83       	std	Y+1, r24	; 0x01
	}
	return Retval;
 d28:	89 81       	ldd	r24, Y+1	; 0x01
}
 d2a:	0f 90       	pop	r0
 d2c:	0f 90       	pop	r0
 d2e:	0f 90       	pop	r0
 d30:	cf 91       	pop	r28
 d32:	df 91       	pop	r29
 d34:	08 95       	ret

00000d36 <BTN_GET_STATUS>:
Std_ReturnType BTN_GET_STATUS(const BTN_T *btn,BTN_STATUS *btn_st){
 d36:	df 93       	push	r29
 d38:	cf 93       	push	r28
 d3a:	00 d0       	rcall	.+0      	; 0xd3c <BTN_GET_STATUS+0x6>
 d3c:	00 d0       	rcall	.+0      	; 0xd3e <BTN_GET_STATUS+0x8>
 d3e:	00 d0       	rcall	.+0      	; 0xd40 <BTN_GET_STATUS+0xa>
 d40:	cd b7       	in	r28, 0x3d	; 61
 d42:	de b7       	in	r29, 0x3e	; 62
 d44:	9c 83       	std	Y+4, r25	; 0x04
 d46:	8b 83       	std	Y+3, r24	; 0x03
 d48:	7e 83       	std	Y+6, r23	; 0x06
 d4a:	6d 83       	std	Y+5, r22	; 0x05
	Std_ReturnType Retval = E_OK;
 d4c:	81 e0       	ldi	r24, 0x01	; 1
 d4e:	89 83       	std	Y+1, r24	; 0x01
	if(NULL == btn || NULL == btn_st){
 d50:	8b 81       	ldd	r24, Y+3	; 0x03
 d52:	9c 81       	ldd	r25, Y+4	; 0x04
 d54:	00 97       	sbiw	r24, 0x00	; 0
 d56:	21 f0       	breq	.+8      	; 0xd60 <BTN_GET_STATUS+0x2a>
 d58:	8d 81       	ldd	r24, Y+5	; 0x05
 d5a:	9e 81       	ldd	r25, Y+6	; 0x06
 d5c:	00 97       	sbiw	r24, 0x00	; 0
 d5e:	11 f4       	brne	.+4      	; 0xd64 <BTN_GET_STATUS+0x2e>
		Retval = E_NOT_OK;
 d60:	19 82       	std	Y+1, r1	; 0x01
 d62:	2d c0       	rjmp	.+90     	; 0xdbe <BTN_GET_STATUS+0x88>
	}
	else{
		LOGIC_T log = GPIO_LOW;
 d64:	1a 82       	std	Y+2, r1	; 0x02
		Retval = GPIO_PIN_READ_LOGIC(&(btn->PIN),&log);
 d66:	8b 81       	ldd	r24, Y+3	; 0x03
 d68:	9c 81       	ldd	r25, Y+4	; 0x04
 d6a:	9e 01       	movw	r18, r28
 d6c:	2e 5f       	subi	r18, 0xFE	; 254
 d6e:	3f 4f       	sbci	r19, 0xFF	; 255
 d70:	b9 01       	movw	r22, r18
 d72:	0e 94 d5 01 	call	0x3aa	; 0x3aa <GPIO_PIN_READ_LOGIC>
 d76:	89 83       	std	Y+1, r24	; 0x01
		if(BTN_ACTIVE_HIGH == btn->BTN_CON){
 d78:	eb 81       	ldd	r30, Y+3	; 0x03
 d7a:	fc 81       	ldd	r31, Y+4	; 0x04
 d7c:	81 81       	ldd	r24, Z+1	; 0x01
 d7e:	88 23       	and	r24, r24
 d80:	61 f4       	brne	.+24     	; 0xd9a <BTN_GET_STATUS+0x64>
			if(GPIO_HIGH == log){
 d82:	8a 81       	ldd	r24, Y+2	; 0x02
 d84:	81 30       	cpi	r24, 0x01	; 1
 d86:	21 f4       	brne	.+8      	; 0xd90 <BTN_GET_STATUS+0x5a>
				*btn_st = BTN_PRESSED;
 d88:	ed 81       	ldd	r30, Y+5	; 0x05
 d8a:	fe 81       	ldd	r31, Y+6	; 0x06
 d8c:	10 82       	st	Z, r1
 d8e:	17 c0       	rjmp	.+46     	; 0xdbe <BTN_GET_STATUS+0x88>
			}
			else{
				*btn_st = BTN_RELEASED;
 d90:	ed 81       	ldd	r30, Y+5	; 0x05
 d92:	fe 81       	ldd	r31, Y+6	; 0x06
 d94:	81 e0       	ldi	r24, 0x01	; 1
 d96:	80 83       	st	Z, r24
 d98:	12 c0       	rjmp	.+36     	; 0xdbe <BTN_GET_STATUS+0x88>
			}
		}
		else if(BTN_ACTIVE_LOW == btn->BTN_CON){
 d9a:	eb 81       	ldd	r30, Y+3	; 0x03
 d9c:	fc 81       	ldd	r31, Y+4	; 0x04
 d9e:	81 81       	ldd	r24, Z+1	; 0x01
 da0:	81 30       	cpi	r24, 0x01	; 1
 da2:	61 f4       	brne	.+24     	; 0xdbc <BTN_GET_STATUS+0x86>
			if(GPIO_HIGH == log){
 da4:	8a 81       	ldd	r24, Y+2	; 0x02
 da6:	81 30       	cpi	r24, 0x01	; 1
 da8:	29 f4       	brne	.+10     	; 0xdb4 <BTN_GET_STATUS+0x7e>
				*btn_st = BTN_RELEASED;
 daa:	ed 81       	ldd	r30, Y+5	; 0x05
 dac:	fe 81       	ldd	r31, Y+6	; 0x06
 dae:	81 e0       	ldi	r24, 0x01	; 1
 db0:	80 83       	st	Z, r24
 db2:	05 c0       	rjmp	.+10     	; 0xdbe <BTN_GET_STATUS+0x88>
			}
			else{
				*btn_st = BTN_PRESSED;
 db4:	ed 81       	ldd	r30, Y+5	; 0x05
 db6:	fe 81       	ldd	r31, Y+6	; 0x06
 db8:	10 82       	st	Z, r1
 dba:	01 c0       	rjmp	.+2      	; 0xdbe <BTN_GET_STATUS+0x88>
			}
		}
		else{
			Retval = E_NOT_OK;
 dbc:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	return Retval;
 dbe:	89 81       	ldd	r24, Y+1	; 0x01
}
 dc0:	26 96       	adiw	r28, 0x06	; 6
 dc2:	0f b6       	in	r0, 0x3f	; 63
 dc4:	f8 94       	cli
 dc6:	de bf       	out	0x3e, r29	; 62
 dc8:	0f be       	out	0x3f, r0	; 63
 dca:	cd bf       	out	0x3d, r28	; 61
 dcc:	cf 91       	pop	r28
 dce:	df 91       	pop	r29
 dd0:	08 95       	ret

00000dd2 <SEGMENT_INITIALIZE>:
 *      Author: Mohamed Elahmady
 */

#include "ECU_7_Segment.h"

Std_ReturnType SEGMENT_INITIALIZE(const SEGMENT_T *seg){
 dd2:	df 93       	push	r29
 dd4:	cf 93       	push	r28
 dd6:	00 d0       	rcall	.+0      	; 0xdd8 <SEGMENT_INITIALIZE+0x6>
 dd8:	00 d0       	rcall	.+0      	; 0xdda <SEGMENT_INITIALIZE+0x8>
 dda:	0f 92       	push	r0
 ddc:	cd b7       	in	r28, 0x3d	; 61
 dde:	de b7       	in	r29, 0x3e	; 62
 de0:	9d 83       	std	Y+5, r25	; 0x05
 de2:	8c 83       	std	Y+4, r24	; 0x04
	Std_ReturnType Retval = E_OK;
 de4:	81 e0       	ldi	r24, 0x01	; 1
 de6:	8b 83       	std	Y+3, r24	; 0x03
	if(NULL== seg){
 de8:	8c 81       	ldd	r24, Y+4	; 0x04
 dea:	9d 81       	ldd	r25, Y+5	; 0x05
 dec:	00 97       	sbiw	r24, 0x00	; 0
 dee:	11 f4       	brne	.+4      	; 0xdf4 <SEGMENT_INITIALIZE+0x22>
		Retval = E_NOT_OK;
 df0:	1b 82       	std	Y+3, r1	; 0x03
 df2:	16 c0       	rjmp	.+44     	; 0xe20 <SEGMENT_INITIALIZE+0x4e>
	}
	else{
		for(int i = 0 ; i < SEGMENT_DECODER_LIMIT ; i++){
 df4:	1a 82       	std	Y+2, r1	; 0x02
 df6:	19 82       	std	Y+1, r1	; 0x01
 df8:	0e c0       	rjmp	.+28     	; 0xe16 <SEGMENT_INITIALIZE+0x44>
			Retval = GPIO_PIN_INITIALIZE(&(seg->SEGMENT_PINS[i]));
 dfa:	2c 81       	ldd	r18, Y+4	; 0x04
 dfc:	3d 81       	ldd	r19, Y+5	; 0x05
 dfe:	89 81       	ldd	r24, Y+1	; 0x01
 e00:	9a 81       	ldd	r25, Y+2	; 0x02
 e02:	82 0f       	add	r24, r18
 e04:	93 1f       	adc	r25, r19
 e06:	0e 94 79 02 	call	0x4f2	; 0x4f2 <GPIO_PIN_INITIALIZE>
 e0a:	8b 83       	std	Y+3, r24	; 0x03
	Std_ReturnType Retval = E_OK;
	if(NULL== seg){
		Retval = E_NOT_OK;
	}
	else{
		for(int i = 0 ; i < SEGMENT_DECODER_LIMIT ; i++){
 e0c:	89 81       	ldd	r24, Y+1	; 0x01
 e0e:	9a 81       	ldd	r25, Y+2	; 0x02
 e10:	01 96       	adiw	r24, 0x01	; 1
 e12:	9a 83       	std	Y+2, r25	; 0x02
 e14:	89 83       	std	Y+1, r24	; 0x01
 e16:	89 81       	ldd	r24, Y+1	; 0x01
 e18:	9a 81       	ldd	r25, Y+2	; 0x02
 e1a:	84 30       	cpi	r24, 0x04	; 4
 e1c:	91 05       	cpc	r25, r1
 e1e:	6c f3       	brlt	.-38     	; 0xdfa <SEGMENT_INITIALIZE+0x28>
			Retval = GPIO_PIN_INITIALIZE(&(seg->SEGMENT_PINS[i]));
		}
	}
	return Retval;
 e20:	8b 81       	ldd	r24, Y+3	; 0x03
}
 e22:	0f 90       	pop	r0
 e24:	0f 90       	pop	r0
 e26:	0f 90       	pop	r0
 e28:	0f 90       	pop	r0
 e2a:	0f 90       	pop	r0
 e2c:	cf 91       	pop	r28
 e2e:	df 91       	pop	r29
 e30:	08 95       	ret

00000e32 <SEGMENT_WRITE_VALUE>:
Std_ReturnType SEGMENT_WRITE_VALUE(const SEGMENT_T *seg , uint8 number){
 e32:	df 93       	push	r29
 e34:	cf 93       	push	r28
 e36:	00 d0       	rcall	.+0      	; 0xe38 <SEGMENT_WRITE_VALUE+0x6>
 e38:	00 d0       	rcall	.+0      	; 0xe3a <SEGMENT_WRITE_VALUE+0x8>
 e3a:	00 d0       	rcall	.+0      	; 0xe3c <SEGMENT_WRITE_VALUE+0xa>
 e3c:	cd b7       	in	r28, 0x3d	; 61
 e3e:	de b7       	in	r29, 0x3e	; 62
 e40:	9d 83       	std	Y+5, r25	; 0x05
 e42:	8c 83       	std	Y+4, r24	; 0x04
 e44:	6e 83       	std	Y+6, r22	; 0x06
	Std_ReturnType Retval = E_OK;
 e46:	81 e0       	ldi	r24, 0x01	; 1
 e48:	8b 83       	std	Y+3, r24	; 0x03
		if(NULL== seg || number > SEGMENT_DIGIT_LIMIT){
 e4a:	8c 81       	ldd	r24, Y+4	; 0x04
 e4c:	9d 81       	ldd	r25, Y+5	; 0x05
 e4e:	00 97       	sbiw	r24, 0x00	; 0
 e50:	19 f0       	breq	.+6      	; 0xe58 <SEGMENT_WRITE_VALUE+0x26>
 e52:	8e 81       	ldd	r24, Y+6	; 0x06
 e54:	8a 30       	cpi	r24, 0x0A	; 10
 e56:	10 f0       	brcs	.+4      	; 0xe5c <SEGMENT_WRITE_VALUE+0x2a>
			Retval = E_NOT_OK;
 e58:	1b 82       	std	Y+3, r1	; 0x03
 e5a:	24 c0       	rjmp	.+72     	; 0xea4 <SEGMENT_WRITE_VALUE+0x72>
		}
		else{
			for(int i = 0 ; i < SEGMENT_DECODER_LIMIT ; i++){
 e5c:	1a 82       	std	Y+2, r1	; 0x02
 e5e:	19 82       	std	Y+1, r1	; 0x01
 e60:	1c c0       	rjmp	.+56     	; 0xe9a <SEGMENT_WRITE_VALUE+0x68>
				Retval = GPIO_PIN_WRITE_LOGIC(&(seg->SEGMENT_PINS[i]) , ((number >> i) & 0x01));
 e62:	2c 81       	ldd	r18, Y+4	; 0x04
 e64:	3d 81       	ldd	r19, Y+5	; 0x05
 e66:	89 81       	ldd	r24, Y+1	; 0x01
 e68:	9a 81       	ldd	r25, Y+2	; 0x02
 e6a:	a9 01       	movw	r20, r18
 e6c:	48 0f       	add	r20, r24
 e6e:	59 1f       	adc	r21, r25
 e70:	8e 81       	ldd	r24, Y+6	; 0x06
 e72:	88 2f       	mov	r24, r24
 e74:	90 e0       	ldi	r25, 0x00	; 0
 e76:	09 80       	ldd	r0, Y+1	; 0x01
 e78:	02 c0       	rjmp	.+4      	; 0xe7e <SEGMENT_WRITE_VALUE+0x4c>
 e7a:	95 95       	asr	r25
 e7c:	87 95       	ror	r24
 e7e:	0a 94       	dec	r0
 e80:	e2 f7       	brpl	.-8      	; 0xe7a <SEGMENT_WRITE_VALUE+0x48>
 e82:	28 2f       	mov	r18, r24
 e84:	21 70       	andi	r18, 0x01	; 1
 e86:	ca 01       	movw	r24, r20
 e88:	62 2f       	mov	r22, r18
 e8a:	0e 94 3a 01 	call	0x274	; 0x274 <GPIO_PIN_WRITE_LOGIC>
 e8e:	8b 83       	std	Y+3, r24	; 0x03
	Std_ReturnType Retval = E_OK;
		if(NULL== seg || number > SEGMENT_DIGIT_LIMIT){
			Retval = E_NOT_OK;
		}
		else{
			for(int i = 0 ; i < SEGMENT_DECODER_LIMIT ; i++){
 e90:	89 81       	ldd	r24, Y+1	; 0x01
 e92:	9a 81       	ldd	r25, Y+2	; 0x02
 e94:	01 96       	adiw	r24, 0x01	; 1
 e96:	9a 83       	std	Y+2, r25	; 0x02
 e98:	89 83       	std	Y+1, r24	; 0x01
 e9a:	89 81       	ldd	r24, Y+1	; 0x01
 e9c:	9a 81       	ldd	r25, Y+2	; 0x02
 e9e:	84 30       	cpi	r24, 0x04	; 4
 ea0:	91 05       	cpc	r25, r1
 ea2:	fc f2       	brlt	.-66     	; 0xe62 <SEGMENT_WRITE_VALUE+0x30>
				Retval = GPIO_PIN_WRITE_LOGIC(&(seg->SEGMENT_PINS[i]) , ((number >> i) & 0x01));
			}
		}
		return Retval;
 ea4:	8b 81       	ldd	r24, Y+3	; 0x03
}
 ea6:	26 96       	adiw	r28, 0x06	; 6
 ea8:	0f b6       	in	r0, 0x3f	; 63
 eaa:	f8 94       	cli
 eac:	de bf       	out	0x3e, r29	; 62
 eae:	0f be       	out	0x3f, r0	; 63
 eb0:	cd bf       	out	0x3d, r28	; 61
 eb2:	cf 91       	pop	r28
 eb4:	df 91       	pop	r29
 eb6:	08 95       	ret

00000eb8 <ECU_INITIALIZE>:
		.LED_Pin.PIN = GPIO_PIN0,
		.LED_Pin.DIRECTION = GPIO_OUTPUT,
		.LED_Pin.LOGIC = GPIO_LOW
};

void ECU_INITIALIZE(void){
 eb8:	df 93       	push	r29
 eba:	cf 93       	push	r28
 ebc:	0f 92       	push	r0
 ebe:	cd b7       	in	r28, 0x3d	; 61
 ec0:	de b7       	in	r29, 0x3e	; 62
	Std_ReturnType Ret = E_NOT_OK;
 ec2:	19 82       	std	Y+1, r1	; 0x01
	Ret = KEYPAD_INITIALIZE(&(keypad1));
 ec4:	88 e8       	ldi	r24, 0x88	; 136
 ec6:	90 e0       	ldi	r25, 0x00	; 0
 ec8:	0e 94 ae 04 	call	0x95c	; 0x95c <KEYPAD_INITIALIZE>
 ecc:	89 83       	std	Y+1, r24	; 0x01
	Ret = LED_INITIALIZE(&(led1));
 ece:	81 e9       	ldi	r24, 0x91	; 145
 ed0:	90 e0       	ldi	r25, 0x00	; 0
 ed2:	0e 94 14 04 	call	0x828	; 0x828 <LED_INITIALIZE>
 ed6:	89 83       	std	Y+1, r24	; 0x01
}
 ed8:	0f 90       	pop	r0
 eda:	cf 91       	pop	r28
 edc:	df 91       	pop	r29
 ede:	08 95       	ret

00000ee0 <main>:
#include "APP.h"

Std_ReturnType Ret = E_NOT_OK;
uint8 var = 0;

int main() {
 ee0:	df 93       	push	r29
 ee2:	cf 93       	push	r28
 ee4:	cd b7       	in	r28, 0x3d	; 61
 ee6:	de b7       	in	r29, 0x3e	; 62
	Application_intialize();
 ee8:	0e 94 91 07 	call	0xf22	; 0xf22 <Application_intialize>
	while(1){
		Ret = KEYPAD_GET_DATA(&keypad1 , &var);
 eec:	88 e8       	ldi	r24, 0x88	; 136
 eee:	90 e0       	ldi	r25, 0x00	; 0
 ef0:	23 e9       	ldi	r18, 0x93	; 147
 ef2:	30 e0       	ldi	r19, 0x00	; 0
 ef4:	b9 01       	movw	r22, r18
 ef6:	0e 94 ef 04 	call	0x9de	; 0x9de <KEYPAD_GET_DATA>
 efa:	80 93 92 00 	sts	0x0092, r24
		if('3' == var){
 efe:	80 91 93 00 	lds	r24, 0x0093
 f02:	83 33       	cpi	r24, 0x33	; 51
 f04:	39 f4       	brne	.+14     	; 0xf14 <main+0x34>
			Ret = LED_TURN_ON(&led1);
 f06:	81 e9       	ldi	r24, 0x91	; 145
 f08:	90 e0       	ldi	r25, 0x00	; 0
 f0a:	0e 94 30 04 	call	0x860	; 0x860 <LED_TURN_ON>
 f0e:	80 93 92 00 	sts	0x0092, r24
 f12:	ec cf       	rjmp	.-40     	; 0xeec <main+0xc>
		}
		else{
			Ret = LED_TURN_OFF(&led1);
 f14:	81 e9       	ldi	r24, 0x91	; 145
 f16:	90 e0       	ldi	r25, 0x00	; 0
 f18:	0e 94 4d 04 	call	0x89a	; 0x89a <LED_TURN_OFF>
 f1c:	80 93 92 00 	sts	0x0092, r24
 f20:	e5 cf       	rjmp	.-54     	; 0xeec <main+0xc>

00000f22 <Application_intialize>:
		}
	}
	return 0;
}
void Application_intialize(void) {
 f22:	df 93       	push	r29
 f24:	cf 93       	push	r28
 f26:	cd b7       	in	r28, 0x3d	; 61
 f28:	de b7       	in	r29, 0x3e	; 62
	ECU_INITIALIZE();
 f2a:	0e 94 5c 07 	call	0xeb8	; 0xeb8 <ECU_INITIALIZE>
}
 f2e:	cf 91       	pop	r28
 f30:	df 91       	pop	r29
 f32:	08 95       	ret

00000f34 <_exit>:
 f34:	f8 94       	cli

00000f36 <__stop_program>:
 f36:	ff cf       	rjmp	.-2      	; 0xf36 <__stop_program>
